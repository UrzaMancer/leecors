# This file was generated based on ".graphqlconfig". Do not edit manually.
# NOTE: This file can not be redownloaded from leetcode web-api anymore,
#       and maybe not updated to time, last fetch time: 2020-02-10.
#
# Sourced from https://github.com/enihsyou/LeetCode/blob/master/leetcode.schema.graphql on 2023-11-12

schema {
    query: Query
    mutation: Mutation
}

"An object with an ID"
interface Node {
    "The ID of the object."
    id: ID!
}

union AdminLogContentNode = AdminLogFlagResultNode | ArticleDeletionRequestNode | BannedUserNode | ColumnArticleNode | CommentRelayNode | FeaturedRequestNode | QAAnswerNode | QAQuestionNode | SolutionArticleNode | SubjectNode | UserNode | UserPermissionNode

union ArticleUnionNode = ColumnArticleNode | SolutionArticleNode

union ArticleWithAllTypeNode = ColumnArticleNode | QAAnswerNode | QAQuestionNode | SolutionArticleNode

union CommunityItemNode = ColumnArticleNode | QAAnswerNode | QAQuestionNode

union EntityNode = BannedUserNode | CommentNode | CommunityTopicNode | FeaturedRequestNode | FeedArticleCommentNode | FeedArticleNode | FeedSubmissionNode | JobsCompanyNode | ProblemCommentNode | QuestionNode | UserNode

union FlaggedArticleNode = FlaggedColumnArticleNode | FlaggedQAAnswerNode | FlaggedQAQuestionNode | FlaggedSolutionNode

union QAQuestionAnswerNode = QAAnswerNode | QAQuestionNode

type AcStatsNode {
    acQuestionCount: Int
    acRate: Int
    acSubmissionCount: Int
    totalSubmissionCount: Int
}

type AcceptAchievementReward {
    error: String
    ok: Boolean
}

type AcceptContribution {
    error: String
    ok: Boolean
}

type AcceptQuestionTranslation {
    error: String
    ok: Boolean
    translation: TranslationNode
}

type AchievementNode {
    achievementDescription: String
    achievementName: String
    created: DateTime!
    idHash: String
    isRewardAccepted: Boolean!
}

type ActivityInfoNode {
    hasMore: Boolean!
    nodes: [ActivityNode!]!
}

type ActivityNode {
    actorNums: Int!
    actors: [EntityNode]
    content: String
    haveRead: Boolean
    link: String
    obj: EntityNode
    target: EntityNode
    updatedAt: Int!
    uuid: String!
    verb: VerbType!
}

type AdPicNode {
    classname: String!
    imgUrl: String!
    isTagShown: Boolean!
    key: String!
    link: String!
}

type AddCommonTag {
    "[deprecated]"
    error: String
    ok: Boolean!
    tag: CommonTagNode
}

"社区， 题解收藏列表"
type AddFavArticle {
    article: ArticleUnionNode
    error: String
    ok: Boolean!
}

type AddOrUpdateCodeInPlayground {
    error: String
    ok: Boolean
}

type AddOrganizationPromotion {
    organization: ContributionOrganizationNode!
}

type AddQuestionToFavorite {
    error: String
    favoriteIdHash: String
    ok: Boolean
    questionId: String
    userName: String
}

type AddQuestionToNewFavorite {
    error: String
    favoriteIdHash: String
    isPublicFavorite: Boolean
    name: String
    ok: Boolean
    questionId: String
    userName: String
}

type AddReaction {
    article: ArticleUnionNode
    error: String
    ok: Boolean!
}

type AddSpecificTypeTag {
    ok: Boolean!
    tag: TagNode
}

type AddTag {
    error: String
    ok: Boolean!
    tagId: ID
}

type AddUserToInternalContest {
    error: String
    user: UserNode
}

type AdminLogContentNodeList {
    logs: [AdminLogNode!]!
    totalNum: Int!
}

type AdminLogFlagResultNode {
    article: FlaggedArticleNode
    comment: FlaggedCommentNode
    created: DateTime!
    "Detailed explanation why the object is set as inappropriate"
    description: String!
    id: ID!
    modified: DateTime!
    "Reason why the resource is set as inappropriate by reviewer"
    reason: FlagReasonNode
    resourceType: ResourceTypeNode!
    reviewer: PrivateContestUserNode
    status: FlagResultStatus!
    topic: CommunityTopicNode
}

type AdminLogNode {
    contentObject: AdminLogContentNode!
    dateCreated: DateTime!
    eventType: EventType!
    user: UserNode!
}

type AnnotatedFavoriteListNode {
    containsQuestion: Boolean!
    favorite: FavoriteNode!
}

type ApplicationNode {
    anonymous: Boolean!
    background: String
    date: Int
    description: String!
    id: ID!
    solutions: String
    status: String
    tags: [String]
    testcases: String
    title: String!
    topic: TopicNode
    type: String
    user: PrivateContestUserNode!
}

type AppliedTranslationNode {
    content: String!
    id: ID!
    lang: String!
    questionId: String!
    title: String!
}

type ApplyForAJob {
    application: JobApplicationNode
    errors: JSONString
    ok: Boolean
}

type ApproveComment {
    error: String
    ok: Boolean
    post: PostNode
}

type ApproveComments {
    error: String
    ok: Boolean
}

type ApproveReportedPost {
    error: String
    ok: Boolean
}

type ApproveTopic {
    error: String
    ok: Boolean
}

type ApproveTopics {
    error: String
    ok: Boolean
}

type ArticleCommonNode {
    articleType: ArticleType!
    author: UserNode!
    byLeetcode: Boolean!
    canEdit: Boolean!
    chargeType: ArticleChargeEnum!
    content: String!
    createdAt: DateTime!
    flagResult: FlagResultNode
    hasVideo: Boolean!
    hitCount: Int!
    isEditorsPick: Boolean!
    isMyFavorite: Boolean!
    reactedType: ArticleReactions
    reactionType: ReactionTypeEnum
    reactions: [ArticleReactionCountNode!]
    reactionsV2: [ReactionCountNode!]
    score: Float
    slug: String!
    status: ArticleStatus!
    summary: String!
    tags: [CommonTagNode!]!
    thumbnail: String!
    title: String!
    topic: TopicNode
    updatedAt: DateTime
    upvoteCount: Int!
    upvoted: Boolean!
    uuid: ID!
    videosInfo: [VideoInfoNode!]
}

type ArticleDeletionRequestConnection {
    "Contains the nodes in this connection."
    edges: [ArticleDeletionRequestEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `ArticleDeletionRequest` and its cursor."
type ArticleDeletionRequestEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: ArticleDeletionRequestNode
}

type ArticleDeletionRequestNode {
    article: QAQuestionNode!
    handledStatus: RequestObjectStatusEnum!
    id: ID!
    rejectReason: String
    requestReason: String!
    requestedAt: Date!
}

type ArticleFeedbackConnection {
    "Contains the nodes in this connection."
    edges: [ArticleFeedbackEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    pendingCount: Int!
    totalNum: Int
}

"A Relay edge containing a `ArticleFeedback` and its cursor."
type ArticleFeedbackEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: ArticleFeedbackNode
}

type ArticleFeedbackNode {
    article: ArticleCommonNode!
    createdAt: DateTime!
    detail: String!
    feedbackReasons: [FeedbackReasonNode!]!
    id: ID!
    modifiedAt: DateTime!
    status: ArticleFeedbackStatus!
    user: UserNode!
}

type ArticleFlagDetail {
    nodes: [FlagNode]!
    totalNum: Int!
}

type ArticleNode {
    canSeeDetail: Boolean
    content: String
    contentTypeId: ID
    id: ID!
    rating: RatingNode
    title: String!
    url: String
}

type ArticlePageNode {
    body: String
    id: ID!
    title: String!
}

type ArticleReactionCountNode {
    count: Int!
    reactionType: ArticleReactions!
}

type AuthCompletePhoneSignUp {
    ok: Boolean!
}

type AuthPasswordChange {
    ok: Boolean!
}

type AuthResetPassword {
    ok: Boolean!
}

type AuthSetPassword {
    ok: Boolean!
}

type AuthSignInWithPassword {
    ok: Boolean!
    token: JSONString
}

type AuthSignInWithPhone {
    created: Boolean!
    "OAuth2 token"
    token: JSONString
}

type AuthSignUpWithEmail {
    errors: AuthSignUpWithEmailErrors
    ok: Boolean!
}

type AuthSignUpWithEmailErrors {
    email: String
    nickname: String
    password: String
}

type AuthSignup {
    errors: AuthSignupErrorsNode
    userStatus: MeNode
}

type AuthSignupErrorsNode {
    all: [FormErrorNode!]
    email: [FormErrorNode!]
    nickname: [FormErrorNode!]
    password1: [FormErrorNode!]
    password2: [FormErrorNode!]
    phone: [FormErrorNode!]
    phoneCode: [FormErrorNode!]
}

type AutoSaveArticle {
    article: ColumnArticleNode
    error: String
    ok: Boolean!
}

type AutoSaveSolutionArticle {
    article: SolutionArticleNode
    error: String
    ok: Boolean!
}

type AwardInternalContestCoin {
    internalContestAwardedUsers: [Int]
    ok: Boolean
}

type BannedUserNode {
    createdAt: DateTime!
    duration: Int!
    endAt: DateTime
    id: ID!
    reason: String!
    status: UserBannedStatus!
    user: UserNode!
}

type BannedUserNodeConnection {
    "Contains the nodes in this connection."
    edges: [BannedUserNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `BannedUserNode` and its cursor."
type BannedUserNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: BannedUserNode
}

type BasicExamNode {
    displayId: String!
    isParticipant: Boolean!
    mode: ExamModeEnum!
    name: String!
}

type BatchReviewFlaggedObjects {
    error: String
    ok: Boolean!
}

type BlacklistNode {
    words: String!
}

type BlockedArticleListNode {
    hasMore: Boolean!
    nodes: [ArticleWithAllTypeNode!]!
}

type BlockedUserListNode {
    hasMore: Boolean!
    nodes: [PublicProfileNode!]!
}

type BlockingBlockArticle {
    ok: Boolean!
}

type BlockingBlockUser {
    ok: Boolean!
}

type CancelOrder {
    error: String!
    ok: Boolean!
}

type CancelUpvoteArticle {
    article: ArticleUnionNode
    error: String
    ok: Boolean
}

type CardExtraFieldsNode {
    card: CardNode!
    displayName: String!
    id: ID!
    keyName: String!
    order: Int!
    required: Boolean!
    valueType: CardExtraFieldsValueType!
}

type CardGroupNode {
    cardInfo: [CardGroupRelationNode!]
    name: String!
    slug: String!
}

type CardGroupRelationNode {
    card: CardNode!
    description: String
    name: String!
}

type CardNode {
    banner: String
    bannerBackground: String
    categorySlug: String
    categoryTitle: String
    chapters: [ChapterNode!]!
    createdAt: DateTime!
    description: String
    discussCategory: DiscussCategoryNode
    extraFields: [CardExtraFieldsNode!]
    havingExtraInfo: CardHavingExtraInfo!
    id: ID!
    img: String
    introText: String
    introduction: String
    invitationThreshold: Int!
    isFavorite: Boolean
    isFeatured: Boolean
    isPreview: Boolean
    items: [ItemNode!]
    lastModified: DateTime!
    numChapters: Int
    numItems: Int
    numUsersCompleted: Int
    numUsersStarted: Int
    paidOnly: Boolean!
    popularity: Int
    prevCompleteLinkInfo: JSONString
    progress: JSONString
    progressPercent: Float!
    published: Boolean!
    sequentialOnly: Boolean!
    slug: String!
    title: String!
    userExtraInfo: JSONString
    users: JSONString
}

type CardProgressNode {
    completedCount: Int!
    itemTotal: Int!
    rate: Int!
}

type CategoryInfoNode {
    "deprecated"
    bookDescription: String!
    bookImgUrl: String!
    bookName: String!
    category: ProblemSetCategoryTypeNode!
    "deprecated"
    description: String!
    fullDescription: String!
    id: ID!
    pressImgUrl: String!
    pressName: String!
    productUrl: String!
    shortDescription: String!
    source: String!
}

type CategoryNode {
    cards(num: Int): [CardNode!]
    description: String
    descriptionEn: String
    descriptionZhHans: String
    id: ID!
    order: Int!
    slug: String!
    title: String!
    titleEn: String
    titleZhHans: String
}

type ChangeArticlesFeedbackStatus {
    ok: Boolean!
}

type ChangeQuestionsFeedbackStatus {
    ok: Boolean!
}

type ChannelNode {
    identifier: String
    name: String
    shortName: String
}

type ChapterNode {
    description: String
    descriptionText: String
    id: ID!
    items: [ItemNode!]
    slug: String!
    title: String!
}

type Checkin {
    checkedIn: Boolean
    error: String
    ok: Boolean
}

type CodeSnippetNode {
    code: String
    lang: String
    langSlug: String
}

type ColumnArticleConnection {
    "Contains the nodes in this connection."
    edges: [ColumnArticleEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `ColumnArticle` and its cursor."
type ColumnArticleEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: ColumnArticleNode
}

type ColumnArticleListNode {
    hasMore: Boolean!
    nodes: [ColumnArticleNode!]!
    totalNum: Int!
}

type ColumnArticleNode {
    articleType: ArticleType!
    author: UserNode!
    byLeetcode: Boolean!
    canEdit: Boolean!
    chargeType: ArticleChargeEnum!
    content: String!
    createdAt: DateTime!
    flagResult: FlagResultNode
    hasVideo: Boolean!
    hitCount: Int!
    identifier: String!
    isEditorsPick: Boolean!
    isMyFavorite: Boolean!
    nextArticle: ColumnArticleNode
    pinned: Boolean!
    pinnedGlobally: Boolean!
    reactedType: ArticleReactions
    reactionType: ReactionTypeEnum
    reactions: [ArticleReactionCountNode!]
    reactionsV2: [ReactionCountNode!]
    resourceType: ResourceTypeEnum!
    score: Float
    slug: String!
    status: ArticleStatus!
    subject: SubjectNode
    subscribed: Boolean!
    summary: String!
    sunk: Boolean!
    tags: [CommonTagNode!]!
    thumbnail: String!
    title: String!
    topic: TopicNode
    updatedAt: DateTime
    upvoteCount: Int!
    upvoted: Boolean!
    uuid: ID!
    videosInfo: [VideoInfoNode!]
}

type ColumnArticleTagListNode {
    nodes: [CommonTagNode!]!
    number: Int!
}

type ColumnsReaction {
    article: ArticleWithAllTypeNode
}

type ColumnsSetArticleAsByLeetCode {
    error: String
    ok: Boolean!
}

type ColumnsSetArticleAsEditorsPick {
    error: String
    ok: Boolean!
}

type ColumnsSetArticleAsRemoved {
    article: ArticleUnionNode
    error: String
    ok: Boolean!
}

type ColumnsSetArticleAsUpdateRequested {
    error: String
    ok: Boolean!
}

type ColumnsSetCommunityArticleAsByLeetCode {
    article: ArticleUnionNode!
}

type ColumnsSetCommunityArticleAsEditorsPick {
    article: ArticleUnionNode!
}

type ColumnsSetFeaturedRequest {
    error: String
    ok: Boolean!
}

type ColumnsTogglePinArticleGlobally {
    article: ArticleUnionNode
    error: String
    ok: Boolean!
}

type ColumnsTogglePinArticleInCategory {
    article: ArticleUnionNode
    error: String
    ok: Boolean!
}

type ColumnsToggleSubscribeArticle {
    article: ArticleUnionNode
    error: String
    ok: Boolean!
}

type ColumnsToggleSunkArticle {
    article: ArticleUnionNode
    error: String
    ok: Boolean!
}

type CommentBelongingNode {
    article: ColumnArticleNode
    kind: String!
    qaAnswer: QAAnswerNode
    question: QuestionNode
    solution: SolutionArticleNode
    topic: CommunityTopicNode @deprecated(reason : "This field will be removed after the legacy community posts have been migrated")
}

type CommentConnection {
    "Contains the nodes in this connection."
    edges: [CommentEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

type CommentContribution {
    error: String
    ok: Boolean
}

"A Relay edge containing a `Comment` and its cursor."
type CommentEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: CommentRelayNode
}

type CommentFlagDetail {
    nodes: [FlagNode]!
    totalNum: Int!
}

type CommentNode {
    children(after: String, before: String, first: Int, last: Int): CommentRelayNodeConnection!
    flagResult: AdminLogFlagResultNode
    flags: [FlagNode!]!
    id: Int!
    index: Int
    lastComment: CommunityTopicNode
    nodebbPid: Int!
    numChildren: Int!
    "Ineffective field: Don't query this field in a list"
    pageNum(numPerPage: Int, orderBy: String): Int
    parent: CommentRelayNode
    parentId: ID
    post: PostNode!
    topic: CommunityTopicNode!
}

type CommentPageInfoNode {
    pageNum: Int!
    parentId: ID
}

type CommentRelayNode implements Node {
    belonging: CommentBelongingNode
    children(after: String, before: String, first: Int, last: Int): CommentRelayNodeConnection!
    "Peek first 2 sub-comments"
    childrenPeek: [CommentRelayNode!]!
    flagResult: AdminLogFlagResultNode
    flags: [FlagNode!]!
    id: ID!
    isEdited: Boolean!
    lastComment: CommunityTopicNode
    nodebbPid: Int!
    numChildren: Int
    parent: CommentRelayNode
    post: PostNode!
    topic: CommunityTopicNode!
    topicId: ID!
}

type CommentRelayNodeConnection {
    "Contains the nodes in this connection."
    edges: [CommentRelayNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `CommentRelayNode` and its cursor."
type CommentRelayNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: CommentRelayNode
}

type CommentWithReplyPageInfoNode {
    pageNum: Int!
    parentId: ID
    replyPageNum: Int
}

type CommonTagNode {
    name: String!
    nameTranslated: String!
    slug: String!
}

type CommunityCreateTopic {
    error: String
    ok: Boolean!
    topic: CommunityTopicNode
}

type CommunityHotTopicListNode {
    hasMore: Boolean!
    nodes: [CommunityTopicNode!]!
}

type CommunityItemListNode {
    nextToken: String
    nodes: [CommunityItemNode!]!
}

type CommunityStatusNode {
    favoredCount: Int!
    subscribedCount: Int!
    viewedCount: Int!
    voteUpCount: Int!
}

type CommunityTagListNode {
    nodes: [CommonTagNode!]!
    number: Int!
}

type CommunityToggleFavorTopic {
    error: String
    ok: Boolean!
    topic: CommunityTopicNode
}

type CommunityTogglePinTopicGlobally {
    error: String
    ok: Boolean!
}

type CommunityTogglePinTopicInSubject {
    error: String
    ok: Boolean!
}

type CommunityToggleSinkTopic {
    error: String
    ok: Boolean!
}

type CommunityToggleSubscribeTopic {
    error: String
    ok: Boolean!
    topic: CommunityTopicNode
}

type CommunityTopicBriefNode {
    id: ID!
    title: String!
}

type CommunityTopicConnection {
    "Contains the nodes in this connection."
    edges: [CommunityTopicEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `CommunityTopic` and its cursor."
type CommunityTopicEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: CommunityTopicNode
}

type CommunityTopicNode {
    author: UserNode!
    commentCount: Int!
    favored: Boolean!
    hitCount: Int!
    id: ID!
    kind: TopicType!
    lastComment: CommentRelayNode
    pinned: Boolean!
    pinnedGlobally: Boolean!
    post: PostNode!
    subject: SubjectNode!
    subscribed: Boolean!
    sunk: Boolean
    tags: [CommonTagNode!]!
    title: String!
    voteUpCount: Int!
}

type CommunityUpdateTopic {
    error: String
    ok: Boolean!
    topic: CommunityTopicNode
}

type CompanyAccountConnection {
    "Contains the nodes in this connection."
    edges: [CompanyAccountEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `CompanyAccount` and its cursor."
type CompanyAccountEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: CompanyAccountNode
}

type CompanyAccountNode {
    "only available to company admins"
    avatar: String
    "only visible to company admins"
    comment: String
    createdAt: DateTime!
    email: String
    employeeId: String
    fullName: String!
    "only visible to company admins"
    isActive: Boolean!
    "first name"
    name: String!
    numPermissions: Int
    participationNum: Int!
    "only visible to company admins"
    permissionCodes: [Int!]
    phone: String
    "only visible to company admins"
    roles: [RoleNode!]
    "only available to company admins"
    userSlug: String
    "only available to company admins"
    username: String
    uuid: UUID!
}

type CompanyAccountTinyInfoNode {
    comment: String!
    email: String!
    employeeId: ID!
    fullName: String!
    nonexistentTagNames: [String!]!
    password: String!
    phone: String!
}

type CompanyNode {
    id: ID!
    name: String!
    slug: String!
}

type CompanySubscriptionStatusNode {
    expiredAt: DateTime!
    frozenUserNumber: Int!
    subscriptionName: String!
    totalTesterNumber: Int!
    totalUserNumber: Int!
    usedUserNumber: Int!
}

type CompanyTagInfoNode implements Node {
    companyQuestionNum: Int!
    "The ID of the object."
    id: ID!
    imgUrl: String
    name: String!
    translatedName: String
}

type CompanyTagNode implements Node {
    frequencies: String
    "The ID of the object."
    id: ID!
    imgUrl: String
    name: String!
    questionIds: [Int]
    questions: [QuestionNode]
    translatedName: String
}

type CompanyUserCandidateConnection {
    "Contains the nodes in this connection."
    edges: [CompanyUserCandidateEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `CompanyUserCandidate` and its cursor."
type CompanyUserCandidateEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: CompanyUserCandidateNode
}

type CompanyUserCandidateNode implements Node {
    email: String!
    "The ID of the object."
    id: ID!
    user: UserNode!
}

type CompanyUserNode {
    accountType: CompanyAccountType!
    accountTypeDisplay: String!
    chinaCity: Int
    chinaCityDisplay: String
    comment: String!
    companyEmail: String
    id: ID!
    linkedTime: DateTime!
    user: PrivateContestUserNode!
}

type CompleteFeatureGuide {
    error: String
    ok: Boolean
    userStatus: MeNode
}

type ConfigNode {
    allowCreate: Boolean!
    allowDisplay: Boolean!
    verb: VerbType!
}

type ConfirmSchoolLogo {
    error: String
    ok: Boolean!
}

type ContestAnnouncementNode {
    content: String!
    currentlyVisible: Boolean
    expiryTime: DateTime!
    id: ID!
    pubDate: DateTime!
}

type ContestGroupNode {
    "html"
    awards: String!
    contestCount: Int!
    contests: [ContestNode!]!
    "html"
    description: String!
    detailUrl: String!
    "html"
    disclosure: String!
    endTime: Int!
    hasRegistered: Boolean!
    registrationClosingTime: Int!
    "html"
    rules: String!
    sponsors: [SponsorNode!]!
    startTime: Int!
    style: JSONString
    subtitle: String!
    title: String!
    titleCn: String!
    titleSlug: String!
    voteSubject: VoteSubjectNode
    wechatShareData: WechatShareDataNode
}

type ContestGroupRegistrationInfoNode {
    fullName: String!
    graduationYear: Int
    occupation: UserProfileOccupation
}

type ContestGroupSchoolStatsNode {
    joinCount: Int!
    schoolId: Int!
    upvoteCount: Int!
}

type ContestNode {
    cardImg: String
    company: SponsorNode
    containsPremium: Boolean
    description: String!
    "in seconds"
    duration: Int!
    isVirtual: Boolean
    originStartTime: Int
    questions: [ContestQuestionNode!]
    startTime: Int!
    title: String!
    titleCn: String
    titleSlug: String
}

type ContestQuestionNode {
    credit: Int!
    questionId: String
    title: String
    titleCn: String
    titleSlug: String
}

type ContestUserUpvoteSchool {
    error: String
    msg: String
    ok: Boolean!
}

type ContributionNode {
    application: ApplicationNode
    applyDate: DateTime!
    category: String
    date: Int
    id: ID!
    lastModified: DateTime!
    library: Int
    payload: JSONString
    status: String
    topic: TopicNode
    user: PrivateContestUserNode!
}

type ContributionOrganizationConnection {
    "Contains the nodes in this connection."
    edges: [ContributionOrganizationEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `ContributionOrganization` and its cursor."
type ContributionOrganizationEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: ContributionOrganizationNode
}

type ContributionOrganizationNode {
    avatarUrl: String!
    createAt: DateTime!
    creator: PrivateContestUserNode
    description: String!
    id: ID!
    members: [UserBriefInfoNode!]!
    modifiedAt: DateTime!
    name: String!
    promotions: [OrganizationPromotionNode!]!
    remarks: String!
}

type ContributorNode {
    avatarUrl: String
    profileUrl: String
    username: String
}

type CooperationPartnerNode {
    link: String!
    logo: String!
    name: String
}

type CreateAppliedQuestionTranslation {
    appliedTranslation: AppliedTranslationNode
    error: String
    ok: Boolean
}

type CreateCnComment {
    comment: CommentRelayNode
    error: String
    ok: Boolean
}

type CreateComment {
    comment: CommentNode
    commentId: Int
    error: String
    ok: Boolean
}

type CreateCompanyUser {
    companyUser: CompanyUserNode
    error: String
    errors: JSONString
    ok: Boolean
}

type CreateContribution {
    error: String
    ok: Boolean
}

type CreateEmail {
    email: EmailNode
    error: String
    ok: Boolean
}

type CreateOrUpdateDraft {
    question: UGCQuestionV2Node!
}

type CreateOrUpdateEmailEvent {
    emailEvent: EmailEventNode
    errors: JSONString
    ok: Boolean
    wasCreated: Boolean
}

type CreateOrUpdateQuestion {
    question: UGCQuestionV2Node!
}

type CreateOrder {
    error: String!
    ok: Boolean!
    orderId: ID
}

type CreatePlayground {
    error: String
    ok: Boolean
    uuid: String
}

type CreatePlaygroundFolder {
    error: String
    ok: Boolean
}

type CreateTopic {
    error: String
    id: Int
    ok: Boolean
}

type CreateTopicForContest {
    error: String
    topic: TopicNode
}

type CreateTopicForQuestion {
    error: String
    topic: TopicNode
}

type CreateTopicWithCategory {
    error: String
    topic: TopicNode
}

type DeleteArticle {
    article: ArticleUnionNode
    error: String
    ok: Boolean!
}

type DeleteCodeFromPlayground {
    error: String
    ok: Boolean
}

type DeleteComment {
    error: String
    ok: Boolean
    post: PostNode
}

type DeleteComments {
    error: String
    ok: Boolean
}

type DeleteCompanyUser {
    error: String
    ok: Boolean!
}

type DeleteDraft {
    error: String
    ok: Boolean
}

type DeleteEducation {
    error: String
    ok: Boolean
}

type DeleteEmail {
    error: String
    ok: Boolean
}

type DeleteNote {
    error: String
    ok: Boolean
}

type DeleteOccupation {
    error: String
    ok: Boolean
}

type DeleteOrganization {
    ok: Boolean!
}

type DeleteOrganizationPromotion {
    ok: Boolean!
}

type DeletePlayground {
    error: String
    ok: Boolean
}

type DeletePlaygroundFolder {
    error: String
    ok: Boolean
}

type DeletePromotion {
    ok: Boolean!
}

type DeleteQuestionSolution {
    question: UGCQuestionV2Node!
}

type DeleteReportedPost {
    error: String
    ok: Boolean
}

type DeleteSocial {
    error: String
    ok: Boolean
}

type DeleteTags {
    error: String
    ok: Boolean!
}

type DeleteTopic {
    error: String
    ok: Boolean
    topic: TopicNode
}

type DeleteTopics {
    error: String
    ok: Boolean
    topics: [TopicNode]
}

type DeliveryAddressNode {
    chinaLocationCode: String!
    detailedAddress: String!
    id: String!
    isDefault: Boolean!
    phoneNumber: String!
    postcode: String
    receiver: String!
}

type DiscountNode {
    availableAfter: DateTime
    availableBefore: DateTime
    availableGroup: String!
    event: String
    id: ID!
    imgUrl: String
    kind: String!
    limit: LimitType!
    limitRule: LimitRule
    price: Int
    value: Int!
}

type DiscussAnnouncementNode {
    content: String!
    dateCreated: DateTime!
    dateUpdated: DateTime!
    display: Boolean!
    id: ID!
}

type DiscussCategoryNode {
    announcement: String
    anonymousEnabled: Boolean!
    canModerate: Boolean!
    canRewardPosts: Boolean!
    description: String
    id: Int!
    numTopics: Int!
    path: String!
    slug: String!
    subcategories: [DiscussCategoryNode!]!
    title: String!
    titleLink: String
}

type DiscussTopicTagNode {
    id: ID!
    name: String!
    numTopics(otherTag: Int): Int!
    order: Int!
    slug: String!
    tagType: TopicTagTagType
}

type EditCompanyProfile {
    company: JobsCompanyNode
    errors: JSONString
    ok: Boolean
}

type EditCompanyUser {
    companyUser: CompanyUserNode
    errors: JSONString
    ok: Boolean
}

type EditTag {
    error: String
    ok: Boolean!
}

type EducationRecordNode {
    degree: String
    endTime: String
    id: ID!
    startTime: String
    toPresent: Boolean!
    unverifiedOrganizationName: String
}

type EmailEventNode {
    emailsendsessionSet: [EmailSendSessionNode!]!
    id: ID!
    minInterval: Int
    notificationIdentifier: String!
    slug: String!
    sqlQuery: String
    template: EmailTemplateNode
    templateId: Int
    testEmails: [String]
    title: String!
    truncatedUsers: [UserNode!]
    userFilter: JSONString
}

type EmailNode {
    email: String!
    primary: Boolean!
    verified: Boolean!
}

type EmailOpenNode {
    email: String!
    extraInfo: String
    id: ID!
    session: EmailSendSessionNode
    time: DateTime
}

type EmailSendSessionNode {
    clicksPerLink: JSONString
    conversionData: JSONString
    emailsLeft: Int
    event: EmailEventNode!
    eventTitle: String
    groupName: String
    id: ID!
    numClicks: Int
    numOpens: Int
    numOpensPerHour: JSONString
    numSent: Int!
    opens: [EmailOpenNode!]!
    overallClickThroughRate: Int
    startTime: String
    template: EmailTemplateNode!
    totalSent: Int
}

type EmailTemplateNode {
    "Resolves the following template variables automatically:<ul><li>advertisement</li><li>blocks</li><li>current_year</li><li>next_contest_formatted_date</li><li>next_contest_title</li><li>next_contest_title_slug</li><li>next_contest_url</li><li>q_description</li><li>q_difficulty_mandarin</li><li>q_difficulty_w_article</li><li>q_num_ac_subs</li><li>real_name</li><li>site_base_url</li><li>storage_base_url</li><li>suggested_q</li><li>suggested_q_slug</li><li>suggested_q_title</li><li>unsubscribe_url</li><li>username</li></ul>"
    content: String!
    conversionTargetUrlTemplates: String
    emailSubject: String!
    emaileventSet: [EmailEventNode!]!
    emailsendsessionSet: [EmailSendSessionNode!]!
    id: ID!
    title: String!
}

type EnableTags {
    error: String
    ok: Boolean!
}

type ErasePremium {
    error: String!
    ok: Boolean!
}

type ExamAccountParticipationNode {
    acQuestionCnt: Int!
    acQuizCnt: Int!
    attemptedTestCaseCnt: Int!
    examDisplayId: String!
    examMode: ExamModeEnum!
    examName: String!
    examType: ExamTypeEnum!
    finishedAt: Int
    numQuestions: Int!
    numQuizzes: Int!
    participationType: ExamParticipationTypeEnum!
    passedTestCaseCnt: Int!
    score: Decimal!
    startedAt: Int!
}

type ExamAddParticipants {
    addedParticipations: [ExamParticipantNode!]!
    ok: Boolean!
}

type ExamAdminLogin {
    ok: Boolean!
}

type ExamCreateExam {
    error: String
    exam: ExamNode
}

type ExamDeleteExam {
    error: String
    ok: Boolean!
}

type ExamDeleteExamTemplate {
    ok: Boolean!
}

type ExamEditExam {
    error: String
    exam: ExamNode
}

type ExamEndExam {
    error: String
    ok: Boolean!
}

type ExamExportExamStatistics {
    id: ID
    ok: Boolean!
}

type ExamImportExamParticipations {
    companyAccounts: [CompanyAccountNode!]!
    ok: Boolean!
}

type ExamLogin {
    ok: Boolean!
}

type ExamNode {
    allowedLanguages: [String!]!
    comment: String
    createdAt: DateTime!
    description: String!
    displayId: String!
    "seconds"
    duration: Int
    endAt: Int!
    frozenOpenMaxNumber: Int!
    mode: ExamModeEnum!
    name: String!
    numAttended: Int!
    numAttendedTesters: Int!
    numParticipants: Int!
    numQuestions: Int!
    numQuizzes: Int!
    numTesters: Int!
    participants: [ExamParticipantNode!]
    questionDetails: [ExamQuestionNode!]
    questions: [QuestionNode!]!
    quizzes: [ExamQuizNode!]
    rules: String!
    startAt: Int!
    templates: [ExamTemplateNode!]!
    type: ExamType!
}

type ExamNotifyParticipants {
    ok: Boolean!
}

type ExamNotifySpecifiedParticipants {
    ok: Boolean!
}

type ExamOpenLogin {
    ok: Boolean!
}

type ExamParticipantConnection {
    "Contains the nodes in this connection."
    edges: [ExamParticipantEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `ExamParticipant` and its cursor."
type ExamParticipantEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: ExamParticipantReportNode
}

type ExamParticipantNode {
    notified: Boolean!
    participant: CompanyAccountNode!
    session: ExamSessionNode
    type: ExamParticipationTypeEnum!
}

type ExamParticipantReportNode {
    acQuestionCnt: Int
    acQuizCnt: Int
    attended: Boolean!
    email: String!
    employeeId: ID
    fullName: String!
    ranking: Int!
    score: Decimal!
    "seconds"
    timeUsed: Int!
    uuid: ID!
}

type ExamParticipantsExport {
    error: String
    id: ID
    ok: Boolean!
}

type ExamParticipantsResultExport {
    error: String
    id: ID
    ok: Boolean!
}

type ExamParticipantsSessionExport {
    error: String
    id: ID
    ok: Boolean!
}

type ExamPasswordLogin {
    ok: Boolean!
}

type ExamQuestionNode {
    numUsed: Int
    order: Int!
    question: QuestionNode!
    score: Int!
    submissionLimit: Int
}

type ExamQuestionOptionNode {
    isOldQuestion: Boolean!
    numUsed: Int!
    question: QuestionNode!
}

type ExamQuizNode {
    answer: JSONString!
    children: [ExamQuizNode!]
    content: String!
    difficulty: QuizDifficultyEnum!
    explanation: String!
    extraContent: JSONString!
    kind: QuizKindEnum!
    numUsed: Int
    order: Int!
    score: Int!
    sourceType: SourceTypeEnum!
    type: QuizTypeEnum!
    uid: String!
}

type ExamQuizOptionNode {
    numUsed: Int!
    quiz: QuizNode!
}

type ExamQuizSubmissionNode {
    children: [ExamQuizSubmissionNode!]!
    score: Int!
    status: ExamQuizSubmissionStatusEnum!
    uid: ID!
    userAnswer: String
}

type ExamQuizzesReplyNode {
    score: Int!
    status: ExamQuizzesReplyStatusEnum!
    submissions: [ExamQuizSubmissionNode!]!
}

type ExamRegisterForExam {
    ok: Boolean!
}

type ExamRemoveParticipants {
    deletedCount: Int!
    ok: Boolean!
}

type ExamReportNode {
    exam: ExamNode!
    numAttended: Int @deprecated(reason : "use numAttended in ExamNode instead")
    participationReport(after: String, before: String, first: Int, last: Int, order: SortingOrderEnum, orderBy: ExamReportOrderEnum, skip: Int): ExamParticipantConnection
}

type ExamRunCode {
    error: String
    ok: Boolean!
    result: RunCodeResult
}

type ExamSaveExamTemplate {
    examTemplate: ExamTemplateNode!
    ok: Boolean!
}

type ExamSaveRecord {
    ok: Boolean!
}

type ExamSendEmailVerification {
    error: ExamSendEmailVerificationError
    "Always return true except for validation errors"
    ok: Boolean!
}

type ExamSessionClientInfoNode {
    browser: String!
    createdAt: DateTime!
    ipInfo: IpInfoNode!
    os: String!
}

type ExamSessionNode {
    acQuestionCnt: Int!
    attemptedTestCaseCnt: Int!
    clientInfos: [ExamSessionClientInfoNode!]
    expiresAt: Int!
    finishedAt: Int
    participant: CompanyAccountNode!
    passedTestCaseCnt: Int!
    quizResult: ExamQuizzesReplyNode
    ranking: Int
    result: [ExamSubmissionStatus!]!
    score: Decimal!
    startedAt: Int!
}

type ExamStartExam {
    session: ExamSessionNode
}

type ExamSubmissionNode {
    code: String!
    compareResult: String @deprecated(reason : "not suitable for display")
    id: ID!
    lang: String!
    memory: String!
    passedTestCaseCnt: Int
    runtime: String!
    statusDisplay: String!
    timestamp: Int!
    totalTestCaseCnt: Int
}

type ExamSubmissionStatus {
    lastSubmission: ExamSubmissionNode
    question: QuestionNode!
    score: Decimal!
    status: ExamQuestionStatusEnum!
    submittedCnt: Int
}

type ExamSubmitCode {
    ok: Boolean!
    submissionId: ID
}

type ExamSubmitQuiz {
    examQuizzesReply: ExamQuizzesReplyNode!
    ok: Boolean!
}

type ExamTemplateNode {
    createdAt: DateTime!
    description: String!
    modifiedAt: DateTime!
    name: String!
    questionNum: Int!
    questionTotalScore: Int!
    questions: [ExamTemplateQuestionNode!]!
    quizNum: Int!
    quizTotalScore: Int!
    quizzes: [ExamTemplateQuizNode!]!
    uuid: UUID!
}

type ExamTemplateQuestionNode {
    numUsed: Int
    order: Int!
    question: QuestionNode!
    score: Int!
    submissionLimit: Int
}

type ExamTemplateQuizNode {
    childrenScore: JSONString!
    numUsed: Int
    order: Int!
    quiz: QuizNode!
    score: Int!
}

type ExamTerminateExam {
    error: String
    ok: Boolean!
}

type ExportResultNode {
    error: String
    ok: Boolean!
    status: String
    storageFile: String
}

type ExportStatusNode {
    file: String!
    fileName: String!
}

type ExportTask {
    id: ID!
}

type FavoriteListNode {
    articles(after: String, before: String, first: Int, last: Int, skip: Int): SolutionArticleConnection!
    modified: DateTime!
    name: String!
}

type FavoriteNode {
    created: DateTime!
    creator: String
    description: String!
    id: ID!
    idHash: String
    isPublicFavorite: Boolean!
    isWatched: Boolean
    lastModified: DateTime!
    name: String!
    questions: [QuestionNode!]!
    user: PrivateContestUserNode!
    viewCount: Int!
}

type FavoritesNode {
    allFavorites: [FavoriteNode]
    officialFavorites: [FavoriteNode]
    privateFavorites: [FavoriteNode]
    publicFavorites: [FavoriteNode]
}

type FeatureNode {
    book: Boolean
    chinaProblemDiscuss: Boolean
    cnJobs: Boolean
    contest: Boolean
    dangerZone: Boolean
    discuss: Boolean
    enableChannels: Boolean
    enableLsp: Boolean!
    enableSharedWorker: Boolean
    mockInterview: Boolean
    mockInterviewNext: Boolean
    questionTranslation: Boolean
    signUp: Boolean
    socialProviders: JSONString
    store: Boolean
    "@deprecated"
    studentFooter: Boolean
    subscription: Boolean
}

type FeaturedRequestContentNode {
    author: UserNode!
    content: String!
    createdAt: DateTime!
    id: ID!
    title: String!
    type: FeaturedRequestType!
    uri: String!
}

type FeaturedRequestListNode {
    nodes: [FeaturedRequestNode]!
    totalNum: Int!
}

type FeaturedRequestNode {
    handledReason: String
    id: ID!
    requestTimes: Int!
    requestedAt: DateTime!
    resource: ArticleCommonNode
    resourceData: FeaturedRequestContentNode!
    status: HandledStatusType!
}

type FeedArticleCommentNode {
    article: ArticleCommonNode
    comment: CommentNode
    qaQuestion: ArticleCommonNode
    question: QuestionNode
}

type FeedArticleNode {
    article: ArticleCommonNode
    deletionRequest: ArticleDeletionRequestNode
    qaQuestion: ArticleCommonNode
    question: QuestionNode
}

type FeedSubmissionNode {
    id: ID!
    lang: SubmissionLang!
    memoryUsed: String!
    question: QuestionNode!
    runtime: String!
    status: SubmissionStatus
    submitTime: Int!
}

type FeedbackReasonNode {
    id: ID!
    name: String!
    order: Int!
    slug: String!
}

type FieldPermissionInfoNode {
    fieldName: String!
    namespace: ResolverNamespaceEnum!
    permissionCodes: [Int!]!
}

type FilteredSubmissionNode {
    code: String!
    codeOutput: String
    compareResult: String
    contest: ContestNode
    date: DateTime!
    examsessionSet: [ExamSessionNode!]!
    id: ID!
    lang: String
    memoryComplexity: SubmissionMemoryComplexity
    question: QuestionNode!
    runtime: Int
    status: String
    timeComplexity: SubmissionTimeComplexity
    totalCorrect: Int
    user: PrivateContestUserNode!
    usersessionSet: [SessionProgressNode!]!
}

type FlagNode {
    description: String!
    id: ID!
    isHandled: Boolean!
    modified: DateTime!
    reason: FlagReasonNode
    reporter: PrivateContestUserNode!
    resourceType: ResourceTypeNode!
}

type FlagPost {
    error: String
    ok: Boolean
}

type FlagReasonNode {
    id: ID!
    name: String!
}

type FlagResultNode {
    created: DateTime!
    "Detailed explanation why the object is set as inappropriate"
    description: String!
    id: ID!
    modified: DateTime!
    "Reason why the resource is set as inappropriate by reviewer"
    reason: FlagReasonNode
    resourceType: ResourceTypeNode!
    reviewer: PrivateContestUserNode
    status: FlagResultStatus!
}

type FlagSetContentStatus {
    error: String
    ok: Boolean!
}

type FlagSomething {
    error: String
    flag: FlagNode
    ok: Boolean!
}

type FlaggedArticleConnection {
    "Contains the nodes in this connection."
    edges: [FlaggedArticleEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `FlaggedArticle` and its cursor."
type FlaggedArticleEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: FlaggedArticleNode
}

type FlaggedColumnArticleNode {
    articleType: ArticleType!
    author: UserNode!
    byLeetcode: Boolean!
    canEdit: Boolean!
    chargeType: ArticleChargeEnum!
    content: String!
    createdAt: DateTime!
    flagCount: Int!
    flagId: ID
    flagResult: FlagResultNode
    hasVideo: Boolean!
    hitCount: Int!
    identifier: String!
    isEditorsPick: Boolean!
    isMyFavorite: Boolean!
    lastFlag: FlagNode
    nextArticle: ColumnArticleNode
    pinned: Boolean!
    pinnedGlobally: Boolean!
    reactedType: ArticleReactions
    reactionType: ReactionTypeEnum
    reactions: [ArticleReactionCountNode!]
    reactionsV2: [ReactionCountNode!]
    resourceType: ResourceTypeEnum!
    score: Float
    slug: String!
    status: ArticleStatus!
    subject: SubjectNode
    subscribed: Boolean!
    summary: String!
    sunk: Boolean!
    tags: [CommonTagNode!]!
    thumbnail: String!
    title: String!
    topic: TopicNode
    updatedAt: DateTime
    upvoteCount: Int!
    upvoted: Boolean!
    uuid: ID!
    videosInfo: [VideoInfoNode!]
}

type FlaggedCommentConnection {
    "Contains the nodes in this connection."
    edges: [FlaggedCommentEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `FlaggedComment` and its cursor."
type FlaggedCommentEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: FlaggedCommentNode
}

type FlaggedCommentNode {
    author: UserNode!
    belonging: CommentBelongingNode
    content: String!
    flagCount: Int!
    flagId: ID
    flagResult: FlagResultNode
    id: ID!
    lastFlag: FlagNode
}

type FlaggedObjectConnection {
    "Contains the nodes in this connection."
    edges: [FlaggedObjectEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `FlaggedObject` and its cursor."
type FlaggedObjectEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: FlaggedObjectNode
}

type FlaggedObjectNode {
    firstFlaggedTime: DateTime!
    flagResult: FlagResultNode!
    flaggedCount: Int!
    reasons: [FlagReasonNode!]
    summary: String!
}

type FlaggedQAAnswerNode {
    articleType: ArticleType!
    author: UserNode!
    byLeetcode: Boolean!
    canEdit: Boolean!
    chargeType: ArticleChargeEnum!
    content: String!
    createdAt: DateTime!
    flagCount: Int!
    flagId: ID
    flagResult: FlagResultNode
    hasVideo: Boolean!
    hitCount: Int!
    identifier: String!
    isEditorsPick: Boolean!
    isMyFavorite: Boolean!
    lastFlag: FlagNode
    nextArticle: ID
    parent: QAQuestionNode
    pinned: Boolean!
    pinnedGlobally: Boolean!
    prevArticle: ID
    reactedType: ArticleReactions
    reactionType: ReactionTypeEnum
    reactions: [ArticleReactionCountNode!]
    reactionsV2: [ReactionCountNode!]
    resourceType: ResourceTypeEnum!
    score: Float
    slug: String! @deprecated(reason : "For reporting purposes only")
    status: ArticleStatus!
    summary: String!
    sunk: Boolean
    thumbnail: String!
    topic: TopicNode
    updatedAt: DateTime
    upvoteCount: Int!
    upvoted: Boolean!
    uuid: ID!
    videosInfo: [VideoInfoNode!]
}

type FlaggedQAQuestionNode {
    alwaysExpand: Boolean!
    alwaysShow: Boolean!
    answered: Boolean
    articleType: ArticleType!
    author: UserNode!
    byLeetcode: Boolean!
    canEdit: Boolean!
    chargeType: ArticleChargeEnum!
    content: String!
    createdAt: DateTime!
    flagCount: Int!
    flagId: ID
    flagResult: FlagResultNode
    hasVideo: Boolean!
    hitCount: Int!
    identifier: String!
    isEditorsPick: Boolean!
    isMyFavorite: Boolean!
    lastFlag: FlagNode
    myAnswerId: ID
    numAnswers: Int!
    numPeopleInvolved: Int!
    numSubscribed: Int!
    pinned: Boolean!
    pinnedGlobally: Boolean!
    reactedType: ArticleReactions
    reactionType: ReactionTypeEnum
    reactions: [ArticleReactionCountNode!]
    reactionsV2: [ReactionCountNode!]
    resourceType: ResourceTypeEnum!
    score: Float
    slug: String! @deprecated(reason : "For reporting purposes only")
    status: ArticleStatus!
    subject: SubjectNode
    subscribed: Boolean!
    summary: String!
    sunk: Boolean
    tags: [CommonTagNode!]!
    thumbnail: String!
    title: String!
    updatedAt: DateTime
    upvoteCount: Int!
    upvoted: Boolean!
    uuid: ID!
    videosInfo: [VideoInfoNode!]
}

type FlaggedSolutionNode {
    articleType: ArticleType!
    author: UserNode!
    byLeetcode: Boolean!
    canEdit: Boolean!
    "题解的付费类型"
    chargeType: ArticleChargeEnum!
    content: String!
    createdAt: DateTime!
    flagCount: Int!
    flagId: ID
    flagResult: FlagResultNode
    hasVideo: Boolean!
    hitCount: Int!
    identifier: String!
    isEditorsPick: Boolean!
    isMostPopular: Boolean!
    isMyFavorite: Boolean!
    lastFlag: FlagNode
    "不建议列表中抓取；下一篇题解"
    nextSolution: String
    "不建议列表中抓取；上一篇题解"
    prevSolution: String
    question: QuestionNode!
    reactedType: ArticleReactions
    reactionType: ReactionTypeEnum
    reactions: [ArticleReactionCountNode!]
    reactionsV2: [ReactionCountNode!]
    resourceType: ResourceTypeEnum!
    score: Float
    slug: String!
    status: ArticleStatus!
    summary: String!
    tags: [CommonTagNode!]!
    thumbnail: String!
    title: String!
    topic: TopicNode
    updatedAt: DateTime
    upvoteCount: Int!
    upvoted: Boolean!
    uuid: ID!
    videosInfo: [VideoInfoNode!]
}

type FlushPremium {
    error: String!
    ok: Boolean!
}

type FollowUser {
    error: String
    ok: Boolean!
}

type FollowUserNode {
    isFollowedByMe: Boolean!
    isFollowingMe: Boolean!
    isMutualFollowing: Boolean!
    user: UserNode
}

type FollowUsersNode {
    allNum: Int!
    users: [FollowUserNode!]
}

type FormErrorNode {
    code: String!
    message: String!
}

type GenerateQuestionTemplate {
    codeDefinitions: JSONString!
    drivers: JSONString
}

type GenerateTestcaseIn {
    ok: Boolean!
}

type GetOrCreateExploreSession {
    cardId: String
    errors: JSONString
    ok: Boolean
    progress: JSONString
}

type GlobalRankingNode {
    myRank: RankingNode
    page: Int
    rankingNodes: [RankingNode!]
    totalUsers: Int
    userPerPage: Int
}

type GrantPremium {
    error: String!
    ok: Boolean!
}

type GrantedPremiumRecordNode {
    createdAt: Float!
    days: Int!
    isSyncedFromUs: Boolean!
    operator: UserNode!
    targetUser: UserNode!
}

type HandleUserReports {
    error: String
    ok: Boolean
}

type HitResource {
    count: Int
    error: String
    ok: Boolean!
}

type HtmlArticleNode {
    html: String!
    id: ID!
    originalLink: String
    paidOnly: Boolean!
}

type InterviewAddCardToFavorites {
    card: InterviewCardNode
    error: String @deprecated(reason : "use GraphQL errors instead")
    ok: Boolean!
}

type InterviewCardNode {
    acRate: Float
    company: InterviewCompanyNode
    id: ID!
    "Is fav of current user? Returns null for anonymous users"
    isFavorite: Boolean
    isPremiumOnly: Boolean!
    lastOpened: Int
    numInterview: Int
    numParticipants: Int
    numPass: Int
    numQuestions: Int
    "Num of questions AC'd by current user, null for anonymous user"
    numQuestionsAced: Int
    order: Int!
    stage: CompanyStage
}

type InterviewCompanyNode {
    description: String!
    id: ID!
    imgUrl: String
    name: String!
    slug: String!
    stage: CompanyStage!
    translatedName: String!
}

type InterviewCompanyOption {
    id: Int!
    keywords: [String!]!
    name: String!
    pinyin: [String!]!
    questionIds: [Int!]!
    slug: String!
}

type InterviewCreateCards {
    error: String
    ok: Boolean!
    taskId: String!
}

type InterviewEnd {
    session: InterviewSessionNode
}

type InterviewNode {
    company: InterviewCompanyNode
    premiumOnly: Boolean!
    questions: [QuestionNode!]!
    "in seconds"
    timeConstraint: Int
}

type InterviewProgressNode {
    questionId: ID!
    status: ProgressStatus!
}

type InterviewQuestionReportNode {
    content: String!
    questionId: String!
    submission: InterviewSubmissionNode
    submissionHistory(after: String, before: String, first: Int, last: Int, skip: Int): InterviewSubmissionConnection!
}

type InterviewRemoveCardFromFavorites {
    card: InterviewCardNode
    error: String @deprecated(reason : "use GraphQL errors instead")
    ok: Boolean!
}

type InterviewReportNode {
    questions: [InterviewQuestionReportNode!]!
}

type InterviewSearchClear {
    ok: Boolean!
}

type InterviewSearchHit {
    error: String
    ok: Boolean!
}

type InterviewSessionConnection {
    "Contains the nodes in this connection."
    edges: [InterviewSessionEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `InterviewSession` and its cursor."
type InterviewSessionEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: InterviewSessionNode
}

type InterviewSessionNode implements Node {
    card: InterviewCardNode!
    distribution: [[Int]!]
    endTime: Int!
    expiredTime: Int!
    "The ID of the object."
    id: ID!
    interview: InterviewNode!
    percentile: Float
    progress: [InterviewProgressNode!]!
    report: InterviewReportNode!
    score: Float
    startTime: Int!
    status: SessionStatus!
    user: PrivateContestUserNode
}

type InterviewSessionNodeConnection {
    "Contains the nodes in this connection."
    edges: [InterviewSessionNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `InterviewSessionNode` and its cursor."
type InterviewSessionNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: InterviewSessionNode
}

type InterviewStageOption {
    id: Int
    name: String
}

type InterviewStart {
    session: InterviewSessionNode
}

type InterviewSubmissionConnection {
    "Contains the nodes in this connection."
    edges: [InterviewSubmissionEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `InterviewSubmission` and its cursor."
type InterviewSubmissionEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: InterviewSubmissionNode
}

type InterviewSubmissionNode implements Node {
    code: String
    "The ID of the object."
    id: ID!
    isPending: String
    lang: String
    memory: String
    numCorrect: Int
    runtime: String
    statusDisplay: String
    timestamp: Int
    total: Int
}

type InterviewSurveyNode {
    companies: [InterviewCompanyOption]
    interviewedUrl: String
    popularCompanies: [InterviewCompanyOption]
    stageOptions: [InterviewStageOption]
    timeOptions: [InterviewTimeOption]
}

type InterviewTimeOption {
    id: Int
    name: String
}

type InterviewedStatsPost {
    error: String
    interviewedStatsId: Int
    ok: Boolean
}

type IpInfoNode {
    area: String!
    city: String!
    country: String!
    ip: String!
    isp: String!
    region: String!
}

type ItemBaseNode {
    article: ArticlePageNode
    cardTitle: String
    chapter: ChapterNode!
    chapterId: Int
    chapterTitle: String
    htmlArticle: HtmlArticleNode
    id: ID!
    info: String
    isComplete: Boolean
    lang: String
    numUsersCompleted: Int
    numUsersStarted: Int
    paidOnly: Boolean
    question: QuestionNode
    type: Int
    users: JSONString
    verboseLang: String
    video: VideoNode
    webPage: WebPageNode
}

type ItemNode {
    article: ArticlePageNode
    cardTitle: String
    chapter: ChapterNode!
    chapterId: Int
    chapterTitle: String
    htmlArticle: HtmlArticleNode
    id: ID!
    info: String
    isComplete: Boolean
    lang: String
    numUsersCompleted: Int
    numUsersStarted: Int
    paidOnly: Boolean
    prerequisites: [ItemBaseNode!]
    question: QuestionNode
    title: String!
    type: Int
    users: JSONString
    verboseLang: String
    video: VideoNode
    webPage: WebPageNode
}

type JobApplicationConnection {
    "Contains the nodes in this connection."
    edges: [JobApplicationEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `JobApplication` and its cursor."
type JobApplicationEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: JobApplicationNode
}

type JobApplicationNode implements Node {
    createdAt: DateTime!
    description: String!
    email: String!
    id: ID!
    isRead: Boolean!
    jobPosting: JobPostingNode!
    phone: String!
    resume: String
    resumePath: String!
    status: ApplicationStatus!
    statusDisplay: String
    userProfile: UserProfileNode
    userRealName: String!
}

type JobApplicationNodeConnection {
    "Contains the nodes in this connection."
    edges: [JobApplicationNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `JobApplicationNode` and its cursor."
type JobApplicationNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: JobApplicationNode
}

type JobInvitationConnection {
    "Contains the nodes in this connection."
    edges: [JobInvitationEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `JobInvitation` and its cursor."
type JobInvitationEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: JobInvitationNode
}

type JobInvitationNode implements Node {
    applications: [JobApplicationNode]
    createdAt: DateTime!
    "The ID of the object."
    id: ID!
    userProfile: UserProfileNode
}

type JobInvitationNodeConnection {
    "Contains the nodes in this connection."
    edges: [JobInvitationNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `JobInvitationNode` and its cursor."
type JobInvitationNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: JobInvitationNode
}

type JobPostingConnection {
    "Contains the nodes in this connection."
    edges: [JobPostingEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

type JobPostingCount {
    count: Int
    status: JobPostingStatusEnum
}

"A Relay edge containing a `JobPosting` and its cursor."
type JobPostingEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: JobPostingNode
}

type JobPostingNode implements Node {
    applications(after: String, before: String, first: Int, isRead: Boolean, last: Int, skip: Int): JobApplicationConnection
    authorizedUsers: [CompanyUserNode]
    chinaCity: String
    chinaCityDisplay: String
    chinaProvince: String
    company: JobsCompanyNode!
    createdAt: DateTime!
    description: String!
    education: JobPostingEducation!
    educationDisplay: String
    enoughExtraUserInfo: Boolean
    hasApplied: Boolean
    id: ID!
    isPassing: Boolean
    location: String!
    relatedCards: [CardNode!]
    "k/month"
    salaryMax: Int
    "k/month"
    salaryMin: Int
    salaryNegotiable: Boolean!
    status: JobPostingStatus!
    statusDisplay: String
    title: String!
    titleSlug: String!
    workExperience: JobPostingWorkExperience!
    workExperienceDisplay: String
}

type JobPromotionApplicationConnection {
    "Contains the nodes in this connection."
    edges: [JobPromotionApplicationEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `JobPromotionApplication` and its cursor."
type JobPromotionApplicationEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: JobPromotionApplicationNode
}

type JobPromotionApplicationNode implements Node {
    application: JobApplicationNode
    applications: [JobApplicationNode]
    enableInvite: Boolean!
    extraInfo: JSONString
    haveInvited: Boolean!
    "The ID of the object."
    id: ID!
    profile: UserProfileNode!
    progress: CardProgressNode!
    progressPercent: Float!
}

type JobPromotionConnection {
    "Contains the nodes in this connection."
    edges: [JobPromotionEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `JobPromotion` and its cursor."
type JobPromotionEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: JobPromotionNode
}

type JobPromotionNode implements Node {
    appliedCount: Int!
    card: CardNode
    channel: JobPromotionChannel!
    channelDisplay: String!
    company: JobsCompanyNode!
    id: ID!
    visitedCount: Int!
}

type JobsCompanyNode {
    authorization: String
    authorizationPath: String
    businessLicense: String
    businessLicensePath: String
    description: String!
    financingStage: CompanyFinancingStage!
    financingStageDisplay: String
    industry: CompanyIndustry!
    industryDisplay: String
    isLegalFileEditable: Boolean
    isLite: Boolean!
    isVerified: Boolean!
    jobPostingNum: Int
    jobPostingNums: [JobPostingCount]
    jobsWebsite: String!
    legalName: String!
    logo: String
    logoPath: String
    name: String!
    nameSlug: String!
    permissions: JobsCompanyPermissionsNode
    scale: CompanyScale!
    scaleDisplay: String
    website: String!
}

type JobsCompanyPermissionsNode {
    canInviteAllSite: Boolean!
    canInviteUsers: Boolean!
    "Max number of users a company can create (except manager)"
    companyUserQuota: Int!
    companyUserQuotaAvailable: Int
    "Max number of job postings a company can create"
    jobPostingQuota: Int!
    jobPostingQuotaAvailable: Int
    leftInviteTimes: Int!
    "Max number of explored users visible to company"
    maxVisibleExploredUser: Int!
}

"LeetCode Push Notification"
type LCPNSaveDeviceToken {
    ok: Boolean!
}

type LanguageLevelNode {
    langName: String!
    langVerboseName: String!
    level: Int!
}

type LanguageNode {
    id: Int
    name: String
    verboseName: String
}

type LibraryLanguageNode {
    displayStr: String!
    environmentInfo: String!
    fileExtension: String!
    name: String!
}

type Like {
    error: String
    likeResult: Boolean
    ok: Boolean
}

type LimitRule {
    maxTimes: Int
}

type LocalRankingNode {
    myRank: RankingNode
    page: Int
    rankingNodes: [RankingNode!]
    totalUsers: Int
    userPerPage: Int
}

type Logout {
    ok: Boolean!
}

type ManagementAddSubject {
    subjects: [SubjectNode!]
}

type ManagementBannedUser {
    bannedUser: BannedUserNode
}

type ManagementCancelBanned {
    bannedUser: BannedUserNode
}

type ManagementCreateOrUpdateUserRole {
    user: UserPermissionNode
}

type ManagementDeleteSubject {
    subjects: [SubjectNode!]
}

type ManagementEditArticlesReview {
    error: String
    ok: Boolean!
}

type ManagementEditBannedTime {
    bannedUser: BannedUserNode
}

type ManagementEditCommentsReview {
    error: String
    ok: Boolean!
}

type ManagementEditFeaturedRequests {
    error: String!
    ok: Boolean!
}

type ManagementReviewDeletionRequest {
    deletionRequest: ArticleDeletionRequestNode
}

type ManagementSortSubjects {
    subjects: [SubjectNode!]
}

type ManagementUpdateSubject {
    subjects: [SubjectNode!]
}

type MarkItemComplete {
    cardId: String
    errors: JSONString
    newProgress: JSONString
    ok: Boolean
}

type MarkItemIncomplete {
    cardId: String
    errors: JSONString
    newProgress: JSONString
    ok: Boolean
}

type MarkRead {
    error: String
    ok: Boolean!
}

type MarkReadAll {
    error: String
    ok: Boolean!
}

type MeNode {
    activeSessionId: Int
    avatar: String
    checkedInToday: Boolean
    completedFeatureGuides: [FeatureGuideType]
    currentSchool: UserSchoolNode
    fullName: String
    groups: [Group]
    isAdmin: Boolean
    isEducationNetwork: Boolean!
    isPhoneVerified: Boolean!
    isPremium: Boolean!
    isSignedIn: Boolean
    isStaff: Boolean
    isSuperuser: Boolean
    isTranslator: Boolean
    isVerified: Boolean
    isWechatVerified: Boolean
    jobsCompany: JobsCompanyNode
    notificationStatus: UserNotificationNode
    optedIn: Boolean
    permissions: [Permission]
    premiumCreatedAt: Float
    premiumExpiredAt: Float
    realName: String
    region: String
    requestRegion: String
    socketToken: String!
    useTranslation: Boolean!
    userSlug: String
    username: String
}

type MerchandiseCategoryType {
    id: Int
    merchandiseSet: [MerchandiseNode!]!
    name: String
    slug: String
}

type MerchandiseEventNode {
    description: String
    endedAt: DateTime!
    name: String!
    slug: ID!
    startedAt: DateTime!
}

type MerchandiseNode {
    category: MerchandiseCategoryType
    coinValue: Int!
    daysOfMembership: Int
    description: String
    forSale: Boolean!
    id: ID!
    img: String
    isVirtual: Boolean!
    name: String!
    quantityAvailable: Int
    slug: String!
    type: MerchandiseType
    "Person who can generate code for this kind of merchandise"
    vendor: PrivateContestUserNode
}

type MergeTags {
    error: String
    ok: Boolean!
    tagId: ID
}

type Mutation {
    acceptAchievementReward(achievementName: String!): AcceptAchievementReward
    acceptContribution(comment: String, contributionId: ID): AcceptContribution
    acceptQuestionTranslation(content: String, title: String, translationId: Int): AcceptQuestionTranslation
    addCommonTag(tagName: String!): AddCommonTag
    addFavoriteArticle(data: AddFavArticleInput!): AddFavArticle
    addOrUpdateCodeInPlayground(code: String, langSlug: String, uuid: String): AddOrUpdateCodeInPlayground
    addQuestionToFavorite(favoriteIdHash: String, questionId: String): AddQuestionToFavorite
    addQuestionToNewFavorite(isPublicFavorite: Boolean, name: String, questionId: String): AddQuestionToNewFavorite
    addReaction(articleId: ID, articleSlug: String, reactionType: ArticleReactions!): AddReaction
    addSpecificTypeTag(tagName: String!, tagType: AddableTagTypeEnum!): AddSpecificTypeTag
    addTag(data: AddTagInput!): AddTag
    addUserToInternalContest(userInput: String): AddUserToInternalContest
    applyForAJob(data: ApplyForAJobInput!): ApplyForAJob
    approveComment(id: Int): ApproveComment
    approveComments(ids: [Int]): ApproveComments
    approveReportedPosts(postIds: [Int]!): ApproveReportedPost
    approveTopic(id: Int): ApproveTopic
    approveTopics(ids: [Int]): ApproveTopics
    authCompletePhoneSignUp(data: AuthCompletePhoneSignUpInput!): AuthCompletePhoneSignUp
    authPasswordChange(data: AuthPasswordChangeInput!): AuthPasswordChange
    authPasswordReset(data: AuthResetPasswordInput!): AuthResetPassword
    authPasswordSet(data: AuthSetPasswordInput!): AuthSetPassword
    authSignInWithPassword(client: OAuthInput, data: AuthSignInWithPasswordInput!): AuthSignInWithPassword
    authSignInWithPhone(client: OAuthInput, data: AuthSignInWithPhoneInput!): AuthSignInWithPhone
    authSignUpWithEmail(data: AuthSignUpWithEmailInput!): AuthSignUpWithEmail
    authSignup(data: AuthSignupInput!): AuthSignup @deprecated(reason : "Mobile login\/Registration uses authSignInWithPhone, email registration uses authSignUpWithEmail,")
    autoSaveSolutionArticle(data: AutoSaveSolutionArticleInput): AutoSaveSolutionArticle
    awardInternalContestCoin(coins: Int, contestSlug: String, userId: Int): AwardInternalContestCoin
    batchReviewFlaggedObjects(data: BatchReviewFlaggedObjectsInput!): BatchReviewFlaggedObjects
    blockingBlockArticle(data: BlockingBlockArticleInput!): BlockingBlockArticle
    blockingBlockUser(
        action: Boolean!,
        userSlug: String!
    ): BlockingBlockUser
    cancelOrder(orderId: String!): CancelOrder
    cancelUpvoteArticle(articleId: ID, articleSlug: String): CancelUpvoteArticle
    checkin: Checkin
    columnsAutoSaveArticle(data: AutoSaveArticleInput): AutoSaveArticle
    """
    Accepts slug of a brand new draft(not draft of a published article),
    a published article or an article requested to update
    """
    columnsPublishArticle(data: PublishArticleInput!): PublishArticle
    columnsReaction(data: ColumnsReactionInput!): ColumnsReaction
    columnsSetArticleAsByLeetCode(slug: String!, value: Boolean!): ColumnsSetArticleAsByLeetCode
    columnsSetArticleAsEditorsPick(slug: String!, value: Boolean!): ColumnsSetArticleAsEditorsPick
    columnsSetArticleAsRemoved(slug: String!, value: Boolean!): ColumnsSetArticleAsRemoved
    columnsSetArticleAsUpdateRequested(description: String, reasonId: ID, slug: String!): ColumnsSetArticleAsUpdateRequested
    columnsSetCommunityArticleAsByLeetCode(slug: String, uuid: ID, value: Boolean!): ColumnsSetCommunityArticleAsByLeetCode
    columnsSetCommunityArticleAsEditorsPick(slug: String, uuid: ID, value: Boolean!): ColumnsSetCommunityArticleAsEditorsPick
    columnsSetFeaturedRequest(
        requestTimes: Int,
        resourceType: FeaturedRequestType!,
        slug: ID!
    ): ColumnsSetFeaturedRequest
    columnsTogglePinArticleGlobally(
        articleId: ID,
        articleSlug: String,
        #Setting top or cancel
        pinned: Boolean!
    ): ColumnsTogglePinArticleGlobally
    columnsTogglePinArticleInCategory(
        articleId: ID,
        articleSlug: String,
        #Setting top or cancel in category
        pinned: Boolean!
    ): ColumnsTogglePinArticleInCategory
    columnsToggleSubscribeArticle(articleId: ID, articleSlug: String, subscribed: Boolean!): ColumnsToggleSubscribeArticle
    columnsToggleSunkArticle(
        articleId: ID,
        articleSlug: String,
        #Sink or cancel
        sunk: Boolean!
    ): ColumnsToggleSunkArticle
    commentContribution(comment: String, contributionId: ID): CommentContribution
    communityCreateTopic(content: String!, mentionedUserSlugs: [String!], subjectSlug: String!, tagSlugs: [String!], title: String!): CommunityCreateTopic
    communityToggleFavorTopic(favored: Boolean!, topicId: ID!): CommunityToggleFavorTopic
    communityTogglePinTopicGlobally(
        pinned: Boolean,
        topicId: ID!
    ): CommunityTogglePinTopicGlobally
    communityTogglePinTopicInSubject(
        pinned: Boolean,
        topicId: ID!
    ): CommunityTogglePinTopicInSubject
    communityToggleSinkTopic(
        sunk: Boolean,
        topicId: ID!
    ): CommunityToggleSinkTopic
    communityToggleSubscribeTopic(subscribed: Boolean!, topicId: ID!): CommunityToggleSubscribeTopic
    communityUpdateTopic(content: String!, id: ID!, subjectSlug: String!, tagSlugs: [String!], title: String!): CommunityUpdateTopic
    completeFeatureGuide(guideType: FeatureGuideType!): CompleteFeatureGuide
    confirmSchoolLogo(schoolId: Int!): ConfirmSchoolLogo
    contestUserUpvoteSchool(contestGroupSlug: String, schoolId: Int): ContestUserUpvoteSchool @deprecated(reason : "For use in college programming competitions")
    createAppliedQuestionTranslation(content: String, lang: String, title: String, titleSlug: String): CreateAppliedQuestionTranslation
    createCnComment(content: String!, mentionedUserSlugs: [String], parentCommentId: Int, topicId: Int!): CreateCnComment
    createComment(content: String, parentCommentId: Int, topicId: Int): CreateComment
    createCompanyUser(data: CreateCompanyUserInput): CreateCompanyUser
    createContribution(contributionType: String, payload: JSONString): CreateContribution
    createEmail(email: String): CreateEmail
    createOrUpdateEmailEvent(data: String, eventId: Int): CreateOrUpdateEmailEvent
    createOrder(data: CreateOrderInput!): CreateOrder
    createPlayground(name: String, selectedLang: String, testcaseInput: String): CreatePlayground
    createPlaygroundFolder(folderName: String): CreatePlaygroundFolder
    createTopic(content: String, title: String): CreateTopic
    createTopicForContest(content: String, contestTitleSlug: String, title: String): CreateTopicForContest
    createTopicForQuestion(content: String, questionId: Int, tags: [String], title: String): CreateTopicForQuestion
    createTopicWithCategory(anonymous: Boolean, categorySlugs: [String], content: String, tags: [String], title: String): CreateTopicWithCategory
    deleteArticle(slug: String, uuid: ID): DeleteArticle
    deleteCodeFromPlayground(langSlug: String, uuid: String): DeleteCodeFromPlayground
    deleteComment(id: Int): DeleteComment
    deleteComments(ids: [Int]): DeleteComments
    deleteCompanyUser(id: ID!): DeleteCompanyUser
    deleteEducation(id: Int): DeleteEducation
    deleteEmail(email: String): DeleteEmail
    deleteNote(titleSlug: String!): DeleteNote
    deleteOccupation(id: Int): DeleteOccupation
    deletePlayground(uuid: String): DeletePlayground
    deletePlaygroundFolder(folder: String): DeletePlaygroundFolder
    deleteReportedPosts(postIds: [Int]!): DeleteReportedPost
    deleteSocial(provider: String): DeleteSocial
    deleteTags(tagIds: [ID!]!): DeleteTags
    deleteTopic(id: Int): DeleteTopic
    deleteTopics(ids: [Int]): DeleteTopics
    editCompanyProfile(data: EditCompanyInput!): EditCompanyProfile
    editCompanyUser(data: EditCompanyUserInput): EditCompanyUser
    editTag(data: EditTagInput!): EditTag
    enableTags(tagIds: [ID!]!): EnableTags
    erasePremium: ErasePremium
    examAddParticipants(companyAccountUuids: [UUID!]!, examId: String!, type: ExamParticipationTypeEnum!): ExamAddParticipants
    examAdminLogin(
        login: String!,
        password: String!
    ): ExamAdminLogin
    examCreateExam(data: ExamCreateExamInput!): ExamCreateExam
    examDeleteExam(examId: ID!): ExamDeleteExam
    examDeleteExamTemplate(
        uuid: UUID!
    ): ExamDeleteExamTemplate
    examEditExam(data: ExamEditExamInput!): ExamEditExam
    examEndExam(examId: ID!): ExamEndExam
    examExportExamStatistics(displayId: ID!, fileName: String): ExamExportExamStatistics
    examImportExamParticipations(file: String!): ExamImportExamParticipations
    examLogin(data: ExamLoginData!): ExamLogin
    examNotifyParticipants(examId: ID!): ExamNotifyParticipants
    examNotifySpecifiedParticipants(examId: ID!, uuids: [UUID!]!): ExamNotifySpecifiedParticipants
    examOpenLogin(
        login: String!,
        password: String!
    ): ExamOpenLogin
    examParticipantsResultExport(
        displayId: ID!,
        fileName: String,
        includeNotAttended: Boolean,
        type: ExamResultType
    ): ExamParticipantsResultExport
    examParticipantsSessionExport(
        displayId: ID!,
        fileName: String,
        # optional filter: if ommitted, export all
        hasParticipated: Boolean
    ): ExamParticipantsSessionExport
    examPasswordLogin(data: ExamPasswordLoginInput!): ExamPasswordLogin
    examRegisterForExam(examId: String!): ExamRegisterForExam
    examRemoveParticipants(companyAccountUuids: [UUID!]!, examId: String!): ExamRemoveParticipants
    examRunCode(data: ExamRunCodeInput!): ExamRunCode
    examSaveExamTemplate(
        saveExamTemplateInput: ExamSaveExamTemplateInput!
    ): ExamSaveExamTemplate
    examSaveRecord(
        events: [String!]!,
        #exam display id
        examId: ID!
    ): ExamSaveRecord
    examSendEmailVerification(email: String!, examId: ID!): ExamSendEmailVerification
    examStartExam(examId: ID!): ExamStartExam
    examSubmitCode(data: ExamSubmitInput!): ExamSubmitCode
    examSubmitQuiz(
        data: ExamQuizSubmissionInput!,
        examId: ID!
    ): ExamSubmitQuiz
    examTerminateExam(examId: ID!): ExamTerminateExam
    feedbackChangeArticlesFeedbackStatus(ids: [ID!]!, status: StatusEnum!): ChangeArticlesFeedbackStatus
    feedbackChangeQuestionsFeedbackStatus(ids: [ID!]!, status: StatusEnum!): ChangeQuestionsFeedbackStatus
    feedbackSendArticleFeedback(
        detail: String!,
        slug: ID!
    ): SendArticleFeedback
    feedbackSendQuestionFeedback(
        detail: String!,
        reasons: [String!]!,
        slug: ID!
    ): SendQuestionFeedback
    flagPost(content: String, flagType: ReportTypeEnum!, postId: Int!): FlagPost
    flagSetContentStatus(data: ReviewFlaggedObjectInput!): FlagSetContentStatus
    flagSomething(data: FlagInput!): FlagSomething
    flushPremium: FlushPremium
    followUser(userSlug: String!): FollowUser
    getOrCreateExploreSession(cardSlug: String): GetOrCreateExploreSession
    grantPremium(days: Int, username: String): GrantPremium
    handleUserReports(resetAvatar: Boolean, resetUsername: Boolean, userSlug: String, userSlugs: [String]): HandleUserReports
    hitResource(
        #1. article.slug; 2. topic.id;
        entityId: ID!,
        entityType: EntityType!
    ): HitResource
    interviewAddCardToFavorites(cardId: ID!): InterviewAddCardToFavorites
    interviewCreateCards(
        #Will update all enabled tags if not provided
        tagIds: [ID!]
    ): InterviewCreateCards
    interviewEnd: InterviewEnd
    interviewRemoveCardFromFavorites(cardId: ID!): InterviewRemoveCardFromFavorites
    interviewSearchClear: InterviewSearchClear
    interviewSearchHit(cardId: ID!): InterviewSearchHit
    interviewStart(cardId: ID!): InterviewStart
    interviewedStatsPost(interviewedStats: InterviewedStatsInput!): InterviewedStatsPost
    "LeetCode Push Notification"
    lcpnSaveDeviceToken(data: LCPNSaveDeviceTokenInput!): LCPNSaveDeviceToken
    like(isLike: Boolean, titleSlug: String): Like
    logout: Logout
    managementAddSubject(data: ManagementAddSubjectInput!): ManagementAddSubject
    managementBannedUser(duration: Int!, reason: String!, slug: String!): ManagementBannedUser
    managementCancelBanned(slug: String!): ManagementCancelBanned
    managementCreateOrUpdateUserRole(data: ManagementCreateOrUpdateUserRoleInput!): ManagementCreateOrUpdateUserRole
    managementDeleteSubject(id: ID!): ManagementDeleteSubject
    managementEditArticlesReview(
        idList: [ID!]!,
        status: ReviewContentActionType!
    ): ManagementEditArticlesReview
    managementEditBannedTime(duration: Int!, reason: String!, slug: String!): ManagementEditBannedTime
    managementEditCommentsReview(
        idList: [ID!]!,
        status: ReviewContentActionType!
    ): ManagementEditCommentsReview
    managementEditFeaturedRequests(
        idList: [ID!]!,
        reason: String,
        status: HandledStatusType!
    ): ManagementEditFeaturedRequests
    managementReviewDeletionRequest(accept: Boolean!, id: ID!, reason: String): ManagementReviewDeletionRequest
    managementSortSubjects(slugs: [String!]): ManagementSortSubjects
    managementUpdateSubject(data: ManagementUpdateSubjectInput): ManagementUpdateSubject
    markItemComplete(itemId: String, submissionId: Int): MarkItemComplete
    markItemIncomplete(itemId: String): MarkItemIncomplete
    markRead(activityUuid: String!): MarkRead
    markReadAll(subType: ActivitySubType!): MarkReadAll
    mergeTags(data: MergeTagsInput!): MergeTags
    openNotifications: OpenNotifications
    payOrder(data: PayOrderInput!): PayOrder
    paymentCreateAddress(data: CreateAddressInput!): PaymentCreateAddress
    paymentDeleteAddress(data: DeleteAddressInput!): PaymentDeleteAddress
    paymentUpdateAddress(data: UpdateAddressInput!): PaymentUpdateAddress
    performNotificationAction(id: Int): PerformNotificationAction
    postOrEditAJob(data: PostAJobInput!): PostOrEditAJob
    publishContestAnnouncement(content: String): PublishContestAnnouncement
    """
    Accepts slug of a brand new draft(not draft of a published article),
    a published article or an article requested to update
    """
    publishSolutionArticle(data: PublishSolutionArticleInput!): PublishSolutionArticle
    qaAddAnswerReaction(answerId: ID!, reactionType: ArticleReactions!): QAAddAnswerReaction
    qaAddFavAnswer(answerId: ID!): QAAddFavAnswer
    qaDeleteAnswer(uuid: ID!): QADeleteAnswer
    qaDeleteQuestion(uuid: ID!): QADeleteQuestion
    qaEditAnswer(data: QAEditAnswerInput!): QAEditAnswer
    qaEditQuestion(data: QAEditQuestionInput!): QAEditQuestion
    qaPublishAnswer(data: QAPublishAnswerInput!): QAPublishAnswer
    qaPublishQuestion(data: QAPublishQuestionInput!): QAPublishQuestion
    qaRemoveAnswerReaction(answerId: ID!): QARemoveAnswerReaction
    qaRemoveFavAnswer(answerId: ID!): QARemoveFavAnswer
    qaRequestToDeleteQuestion(
        questionId: ID!,
        requestReason: String!
    ): QARequestToDeleteQuestion
    qaSetAnswerAsEditorsPick(answerId: ID!, value: Boolean!): QASetAnswerAsEditorsPick
    qaSetQuestionAsByLeetcode(questionId: ID!, value: Boolean!): QASetQuestionAsByLeetcode
    qaSetQuestionMetaData(data: QASetQuestionMetaDataInput!): QASetQuestionMetaData
    qaTogglePinAnswerInQuestion(
        answerId: ID!,
        pinned: Boolean!
    ): QATogglePinAnswerInQuestion
    qaTogglePinQuestionGlobally(
        pinned: Boolean!,
        questionId: ID!
    ): QATogglePinQuestionGlobally
    qaTogglePinQuestionInCategory(
        pinned: Boolean!,
        questionId: ID!
    ): QATogglePinQuestionInCategory
    qaToggleSubscribeQuestion(subscribed: Boolean!, uuid: ID!): QAToggleSubscribeQuestion
    qaToggleSunk(
        sunk: Boolean!,
        uuid: ID!
    ): QAToggleSunk
    qaUpvoteAnswer(answerId: ID!, upvote: Boolean!): QAUpvoteAnswer
    quizImportQuizzes(file: String!): QuizImportQuizzes
    rateArticle(contentTypeId: ID!, objectId: ID!, score: Int!): RateArticle
    registerContestGroup(schoolId: Int!, slug: String!): RegisterContestGroup @deprecated(reason : "For use in college programming competitions")
    registerForContestGroup(data: RegisterForContestGroupInput!): RegisterForContestGroup
    rejectContribution(comment: String, contributionId: ID): RejectContribution
    rejectQuestionTranslation(translationId: Int): RejectQuestionTranslation
    removeFavoriteArticle(data: RemoveFavArticleInput!): RemoveFavArticle
    removeQuestionFromFavorite(favoriteIdHash: String, questionId: String): RemoveQuestionFromFavorite
    removeReaction(articleId: ID, articleSlug: String): RemoveReaction
    removeUsersFromInternalContest(userIds: [ID]): RemoveUsersFromInternalContest
    reportUser(message: String, userSlug: String!): ReportUser
    requestUpdateToReportedPosts(postIds: [Int]!): RequestUpdateToReportedPost
    saveOrUpdateAsciiCode(code: String!): SaveOrUpdateAsciiCode
    saveTempExportedData(columns: [String]!, data: JSONString!): SaveTempExportedData
    sendInternalContestEmail(content: String, userIds: [ID]): SendInternalContestEmail
    sendInvitation(userSlug: String!): SendInvitation
    sendLeetcodeNotification(htmlContent: String!, link: String): SendLeetCodeNotification
    sendSmsCode(phone: String!, templateId: String!): SendSmsCode
    sendVerificationEmail(email: String): SendVerificationEmail
    sendVerificationSms(smsInput: SendVerificationInput!): SendVerificationSms
    setBlacklist(words: String): SetBlacklistWords
    setCardUserInfo(cardSlug: ID!, userInfo: JSONString!): SetCardUserInfo
    setItemStartTime(itemId: String): SetItemStartTime
    setNotificationSetting(channelIdentifier: String, notificationIdentifier: String, status: Boolean): SetNotificationSetting
    setUserActivityConfig(configs: [SetUserConfigInput]): SetUserConfig
    storeGenerateRedeemCodes(data: StoreGenerateRedeemCodesInput!): StoreGenerateRedeemCodes
    subjectUpdateUserSetting(orderedSlugs: [String!]!): UpdateUserSubjectSetting
    submitQuestionTranslation(content: String, lang: String, title: String, titleSlug: String): SubmitQuestionTranslation
    subscribeQuestion(questionId: String!): SubscribeQuestion
    subscribeTopic(subscribe: Boolean, topicId: Int): SubscribeTopic
    toggleFavorite(cardSlug: String): ToggleFavorite
    togglePinTopic(pinned: Boolean, topicId: Int): TogglePinTopic
    toggleTagIsPublic(isPublic: Boolean!, tagId: ID!): TagToggleIsPublic
    ugcAddOrganizationPromotion(
        organizationId: ID!,
        promotions: [ID!]!
    ): AddOrganizationPromotion
    ugcCreateOrUpdateDraft(data: UGCDraftInput!): CreateOrUpdateDraft
    ugcCreateOrUpdateQuestion(data: UGCQuestionInput!): CreateOrUpdateQuestion
    ugcDeleteDraft(ugcQuestionId: String!): DeleteDraft
    ugcDeleteOrganization(organizationId: ID!): DeleteOrganization
    ugcDeleteOrganizationPromotion(
        organizationId: ID!,
        promotionId: ID!
    ): DeleteOrganizationPromotion
    ugcDeletePromotion(promotionId: ID!): DeletePromotion
    ugcDeleteQuestionSolution(solutionId: ID!, ugcQuestionId: String!): DeleteQuestionSolution
    ugcGenerateOutput(data: UGCGenerateOutputInput!): UGCGenerateOutput
    ugcGenerateQuestionTemplate(data: GenerateQuestionTemplateInput!): GenerateQuestionTemplate
    "Generate test input based on schema"
    ugcGenerateTestcaseIn(inputSchema: JSONString!): GenerateTestcaseIn
    ugcInterpretSolution(data: UGCInterpretSolutionInput!): UGCInterpretSolution
    ugcQuestionSetModelSolution(data: SetModelSolutionInput!): SetModelSolution
    ugcSaveQuestionSolution(solutionId: ID!, ugcQuestionId: String!): SaveQuestionSolution
    ugcSetQuestionAsPrivate(isPrivate: Boolean!, ugcQuestionId: String!): SetQuestionAsPrivate
    ugcTestSolution(data: UGCTestSolutionInput!): UGCTestSolution
    ugcUpdateOrCreateOrganization(data: UpdateOrCreateOrganizationInput!): UpdateOrCreateOrganization
    ugcUpdateOrCreatePromotion(data: UpdateOrCreatePromotionInput!): UpdateOrCreatePromotion
    ugcValidateInputTestCase(data: ValidateTestCaseInput!): ValidateTestCase
    unfollowUser(userSlug: String!): UnfollowUser
    unpublishContestAnnouncement(id: Int): UnpublishContestAnnouncement
    unsubscribeQuestion(questionId: String!): UnsubscribeQuestion
    updateApplicationIsRead(input: UpdateApplicationIsReadInput!): UpdateApplicationIsRead
    updateApplicationStatus(input: UpdateApplicationStatusInput): UpdateApplicationStatus
    updateAppliedQuestionTranslation(appliedTranslationId: Int, content: String, title: String): UpdateAppliedQuestionTranslation
    updateAvatarStatus(viewedSlugs: [String]): UpdateUserAvatarStatus
    updateBetaParticipation(optIn: Boolean!): UpdateBetaParticipation
    updateComment(content: String, id: Int, mentionedUserSlugs: [String]): UpdateComment
    updateContestGroupRegistrationInfo(data: UpdateContestGroupRegistrationInfoInput!): UpdateContestGroupRegistrationInfo
    updateContribution(applicationId: ID, contributionId: ID, contributionType: String, payload: JSONString): UpdateContribution
    updateEducation(degree: String, endTime: String, id: Int!, schoolName: String!, startTime: String, toPresent: Boolean): UpdateEducation
    updateEmailPrimary(email: String): UpdateEmailPrimary
    updateInvalidUsername(username: String): UpdateInvalidUsername
    updateJobStatus(input: UpdateJobStatusInput!): UpdateJobStatus
    updateNote(content: String!, titleSlug: String!): UpdateNote
    updateOccupation(companyName: String!, endTime: String, id: Int!, jobTitle: String!, startTime: String, toPresent: Boolean): UpdateOccupation
    updatePlayground(codeSnippetMode: Boolean, folder: String, isLive: Boolean, isShared: Boolean, name: String, selectedLang: String, testcaseInput: String, uuid: String): UpdatePlayground
    updatePlaygroundFolder(newFolderName: String, oldFolderName: String): UpdatePlaygroundFolder
    updateProblematicPost(content: String, id: Int, title: String): UpdateProblematicPost
    updateProfile(fieldName: String, value: String): UpdateProfile
    updateProfileIndustry(industry: Industry!): UpdateProfileIndustry
    updateQuestionTranslation(content: String, title: String, translationId: Int): UpdateQuestionTranslation
    updateTopic(content: String, id: Int, tags: [String], title: String): UpdateTopic
    updateTopicWithCategory(categorySlugs: [String], content: String, id: Int, tags: [String], title: String): UpdateTopicWithCategory
    updateTranslationConfig(useTranslation: Boolean!): UpdateTranslationConfig
    updateUnifiedNotificationSettings(configs: [UnifiedNotificationSettingsInput!]!): UpdateUnifiedNotificationSettings
    updateUserProfile(data: UpdateProfileInput!): UpdateUserProfile
    updateUserSchool(graduationYear: Int!, schoolName: String!): UpdateUserSchool
    updateUsername(username: String): UpdateUsername
    uploadTagImage(id: ID!, imgUrl: String!): UploadTagImage
    upvoteArticle(articleId: ID, articleSlug: String): UpvoteArticle
    userUploadSchoolLogo(schoolId: Int!, url: String!): UserUploadSchoolLogo
    validatePhoneCode(phoneCode: String!, phoneNum: String!): ValidatePhoneCode
    videosGetUploadCredential(data: VideosGetUploadCredentialInput!): VideosGetUploadCredential
    videosRefreshUploadCredential(videoId: String!): VideosRefreshUploadCredential
    videosSaveUrl(
        videoId: String!
    ): VideosSaveUrl
    voteForItem(itemSlug: String!, subjectSlug: String!): VoteForItem
    votePost(postId: Int, value: Int): VotePost
    wikiContributeContent(data: WikiContributeContentInput!): WikiContributeContent
    wikiToggleEntryPublicStatus(data: WikiToggleEntryPublicStatusInput!): WikiToggleEntryPublicStatus
}

type NOJPermissionNode {
    description: String!
    name: String!
    slug: String!
}

type NOJRoleNode {
    description: String!
    name: String!
    slug: String!
}

type NotificationCategoryNode {
    configurableNotificationTypes: [NotificationTypeNode]
    slug: String
    title: String
}

type NotificationConfigNode {
    enabledChannels: [NotificationChannel!]!
    identifier: NotificationIdentifier!
}

type NotificationConfigurableTypeNode {
    channels: [NotificationChannel!]!
    identifier: NotificationIdentifier!
}

type NotificationConnection {
    "Contains the nodes in this connection."
    edges: [NotificationEdge]!
    id: String
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

type NotificationDataNode {
    content: String!
    id: ID!
    metadata: JSONString
    notificationSet(after: String, before: String, first: Int, last: Int): NotificationNodeConnection!
    type: String!
}

"A Relay edge containing a `Notification` and its cursor."
type NotificationEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: NotificationNode
}

type NotificationNode implements Node {
    actioned: Boolean!
    creationDate: Int
    "The ID of the object."
    id: ID!
    modifiedDate: Int!
    notificationData: NotificationDataNode!
    notificationId: Int
    user: UserNode
}

type NotificationNodeConnection {
    "Contains the nodes in this connection."
    edges: [NotificationNodeEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
}

"A Relay edge containing a `NotificationNode` and its cursor."
type NotificationNodeEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: NotificationNode
}

type NotificationTypeNode {
    channelSettings: JSONString
    identifier: String
    name: String
}

type NotificationUnifiedSettingsNode {
    settings: [NotificationConfigNode!]!
}

type OccupationRecordNode {
    endTime: String
    id: ID!
    jobTitle: String
    startTime: String
    toPresent: Boolean!
    unverifiedOrganizationName: String
}

type OpenNotifications {
    error: String
    ok: Boolean
}

type OrderItemNode {
    count: Int!
    isGift: Boolean!
    product: ProductNode!
}

type OrderNode {
    address: DeliveryAddressNode
    body: String!
    channel: String!
    createdAt: Float!
    currency: String!
    descriptionMeta: String
    expiredAt: Float!
    id: ID!
    isPaid: Boolean!
    isRefunded: Boolean!
    items: [OrderItemNode!]!
    onlyVirtualProduct: Boolean!
    originalPrice: Int
    paidAt: Float
    productDiscounts: [DiscountNode!]
    refundedAt: Float
    refunds: [RefundNode!]!
    subject: String!
    totalPrice: Int!
}

type OrganizationPromotionNode {
    aboutLink: String!
    avatarUrl: String!
    createAt: DateTime!
    creator: PrivateContestUserNode
    description: String!
    id: ID!
    modifiedAt: DateTime!
    name: String!
}

"The Relay compliant `PageInfo` type, containing data necessary to paginate this connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type PagifiedCommentNode {
    currentPage: Int
    data: [CommentNode]
    numPerPage: Int
    pageNum: Int
    totalNum: Int
}

type PagifiedContributionNode {
    currentPage: Int
    data: [ContributionNode]
    numPerPage: Int
    pageNum: Int
    totalNum: Int
}

type PagifiedPostNode {
    currentPage: Int
    data: [PostNode]
    numPerPage: Int
    pageNum: Int
    totalNum: Int
}

type PagifiedTopicNode {
    currentPage: Int
    data: [TopicNode]
    numPerPage: Int
    pageNum: Int
    totalNum: Int
}

type PagifiedTranslationNode {
    currentPage: Int
    data: [TranslationNode]
    numPerPage: Int
    pageNum: Int
    totalNum: Int
}

type PagifiedUserNode {
    currentPage: Int
    data: [UserNode]
    numPerPage: Int
    pageNum: Int
    totalNum: Int
}

type PagifiedUserReportNode {
    currentPage: Int
    data: [UserReportNode]
    numPerPage: Int
    pageNum: Int
    totalNum: Int
}

type PayOrder {
    chargeId: ID
    chargeJsonObject: String
    credential: String
    error: String!
    ok: Boolean!
}

type PaymentCreateAddress {
    address: DeliveryAddressNode!
}

type PaymentDeleteAddress {
    ok: Boolean!
}

type PaymentUpdateAddress {
    address: DeliveryAddressNode!
}

type PerformNotificationAction {
    error: String
    notification: NotificationNode
    ok: Boolean
}

type PermissionModuleNode {
    name: String!
    permissions: [PermissionNode!]!
}

type PermissionNode {
    code: Int!
    desc: String!
    name: String!
}

type PlaygroundCodeNode {
    code: String!
    lang: PlaygroundCodeLang!
    langSlug: String
    modifiedDate: DateTime!
    playground: PlaygroundNode!
}

type PlaygroundDatasetNode {
    description: String!
    name: String!
    slug: String!
}

type PlaygroundFolderNode {
    name: String!
    playgroundSet: [PlaygroundNode!]!
    user: PrivateContestUserNode!
}

type PlaygroundNode {
    folder: PlaygroundFolderNode
    isLive: Boolean
    isShared: Boolean
    isUserOwner: Boolean
    modifiedDate: DateTime!
    name: String!
    playgroundcodeSet: [PlaygroundCodeNode!]!
    selectedLang: PlaygroundSelectedLang
    selectedLangSlug: String
    showOpenInPlayground: Boolean
    showRunCode: Boolean
    testcaseInput: String!
    uuid: String!
}

type PlaygroundSnippetNode {
    dependencies: [PlaygroundSnippetNode!]!
    description: String!
    foldingPositions: [Int]
    fullSnippetWithDependencies: String
    functionName: String!
    hasDependencies: Boolean
    hidden: Boolean!
    lang: PlaygroundSnippetsLang!
    langSlug: String
    playgroundsnippetsSet: [PlaygroundSnippetNode!]!
    snippet: String!
}

type PlaygroundTemplateCodeNode {
    foldingPositions: [Int]
    lang: PlaygroundTemplateCodeLang!
    langSlug: String
    templateCode: String!
}

type PlaygroundTemplateNode {
    codes(langSlug: String): [PlaygroundTemplateCodeNode!]
    name: String!
    nameSlug: String!
    templateId: String
    testcaseInput: String!
    user: PrivateContestUserNode!
}

type PointListNode {
    hasNext: Boolean
    points: [ScoreNode]
}

type PostMentionedUser {
    key: String!
    nickName: String!
    userSlug: String!
    username: String!
}

type PostNode {
    anonymous: Boolean!
    asTopic: Boolean
    author: UserNode
    authorIsModerator: Boolean
    coinRewards: [ScoreNode!]!
    comment: CommentRelayNode
    content: String!
    creationDate: Int
    id: Int!
    isOwnPost: Boolean
    isReported: Boolean
    mentionedUsers: [PostMentionedUser]
    nodebbPid: Int!
    originalContent: String!
    peek: String
    reports: [ReportInfoNode]
    status: String
    topic: CommunityTopicNode
    topicTitle: String
    updationDate: Int
    voteCount: Int!
    voteSet: [VoteNode!]!
    voteStatus: Int
    voteUpCount: Int!
}

type PostOrEditAJob {
    error: String
    errors: JSONString
    jobPosting: JobPostingNode
    ok: Boolean
}

type PrivateContestUserNode {
    achievementSet: [AchievementNode!]!
    applicationSet(after: String, before: String, first: Int, last: Int): JobApplicationNodeConnection!
    appliedquestiontranslationSet: [AppliedTranslationNode!]!
    articlefeedbackSet: [ArticleFeedbackNode!]!
    articlepageSet: [ArticlePageNode!]!
    columnsFavoriteLists: [FavoriteListNode!]!
    companyAccounts: [CompanyAccountNode!]!
    companySet: [SponsorNode!]!
    companyuser: CompanyUserNode
    contestgroupSet: [ContestGroupNode!]!
    contributionSet: [ContributionNode!]!
    contributorSet: [ContributorNode!]!
    createdOrganizations: [ContributionOrganizationNode!]!
    createdPromotions: [OrganizationPromotionNode!]!
    createdQuestions: [UGCQuestionV2Node!]!
    createdQuizzes: [QuizNode!]!
    createdSolutions: [UGCQuestionSolutionNode!]!
    dateJoined: DateTime!
    educationrecordSet: [EducationRecordNode!]!
    email: String
    emailaddressSet: [EmailNode!]!
    emails: [EmailNode]
    exportedfileSet: [ExportStatusNode!]!
    favoriteSet: [FavoriteNode!]!
    firstName: String!
    flagSet: [FlagNode!]!
    flagresultSet: [AdminLogFlagResultNode!]!
    id: ID
    individualQuestions: [UGCQuestionV2Node!]!
    invitationSet(after: String, before: String, first: Int, last: Int): JobInvitationNodeConnection!
    isActive: Boolean!
    isDiscussAdmin: Boolean
    isDiscussStaff: Boolean
    isStaff: Boolean!
    isSuperuser: Boolean!
    jobCompany: [JobsCompanyNode!]!
    jobsCompany: JobsCompanyNode
    lastLogin: DateTime
    lastName: String!
    lastParticipatedContest: ContestNode
    "Person who can generate code for this kind of merchandise"
    merchandiseSet: [MerchandiseNode!]!
    merchandiseeventSet: [MerchandiseEventNode!]!
    modifiedQuizzes: [QuizNode!]!
    notificationSet(after: String, before: String, first: Int, last: Int): NotificationNodeConnection!
    occupationrecordSet: [OccupationRecordNode!]!
    organizations: [ContributionOrganizationNode!]!
    participatedTimes: Int!
    password: String!
    phone: String
    playgroundSet: [PlaygroundNode!]!
    playgroundfolderSet: [PlaygroundFolderNode!]!
    playgroundtemplateSet: [PlaygroundTemplateNode!]!
    postReport: [ReportInfoNode!]!
    postSet: [PostNode!]!
    profile: UserProfileNode!
    questionapplicationSet: [ApplicationNode!]!
    questionfeedbackSet: [QuestionFeedbackNode!]!
    questiontranslationSet: [TranslationNode!]!
    ranking: RankingNode
    reportee: [UserReportNode!]!
    reporter: [UserReportNode!]!
    schools: [UserSchoolNode!]!
    scoreUser: [ScoreNode!]!
    sessionSet(after: String, before: String, first: Int, last: Int): InterviewSessionNodeConnection!
    socialAccounts: [String]
    socialaccountSet: [SocialAccountNode!]!
    submissionSet: [FilteredSubmissionNode!]!
    usermerchandiseeventSet: [UserMerchandiseEventNode!]!
    username: String!
    userratingSet: [UserRatingNode!]!
    usersessionSet: [SessionProgressNode!]!
    userskilltagSet: [UserSkillTagNode!]!
    videos: [VideosVideoNode!]!
    virtualcontestscoreSet: [VirtualContestScoreNode!]!
    voteSet: [VoteNode!]!
}

type ProblemCommentNode {
    comment: CommentNode
    question: QuestionNode!
}

type ProblemSetCategoryTypeNode {
    title: String!
    titleSlug: String!
}

type ProblemSubscribedNode {
    hasMore: Boolean!
    nodes: [QuestionNode!]!
}

type ProductNode {
    categorySlug: String!
    currency: String!
    description: String!
    discount: DiscountNode
    discountPriceForNew: Int
    discounts: [DiscountNode!]!
    gifts: [ProductNode!]!
    id: ID!
    image: String
    meta: String
    name: String!
    price: Int!
    promoChannel: PromoChannelNode
    slug: String!
}

type ProgressQuestionListNode {
    questions: [ProgressQuestionNode!]!
    totalNum: Int!
}

type ProgressQuestionNode {
    difficulty: DifficultyEnum!
    frontendId: String!
    lastSubmittedAt: Int
    numSubmitted: Int
    title: String!
    titleSlug: String!
    translatedTitle: String
}

type PromoChannelNode {
    availableAfter: DateTime
    availableBefore: DateTime
    name: String!
    slug: String!
}

type PublicBuyerNode {
    avatarUrl: String!
    nickname: String!
}

type PublicOrderNode {
    address: DeliveryAddressNode
    body: String!
    buyer: PublicBuyerNode!
    createdAt: Float!
    currency: String!
    descriptionMeta: String
    expiredAt: Float!
    id: ID!
    items: [OrderItemNode!]!
    onlyVirtualProduct: Boolean!
    originalPrice: Int
    subject: String!
    totalPrice: Int!
}

type PublicProfileNode {
    educationRecordList: [EducationRecordNode!]
    firstName: String!
    isBlocked: Boolean
    isFollowed: Boolean
    lastName: String!
    occupationRecordList: [OccupationRecordNode!]
    profile: UserProfileNode!
    siteRanking: Int
    submissionProgress: SubmissionProgressNode
    username: String!
}

"""
Accepts slug of a brand new draft(not draft of a published article),
a published article or an article requested to update
"""
type PublishArticle {
    article: ColumnArticleNode
    error: String
    ok: Boolean!
}

type PublishContestAnnouncement {
    ok: Boolean
}

"""
Accepts slug of a brand new draft(not draft of a published article),
a published article or an article requested to update
"""
type PublishSolutionArticle {
    article: SolutionArticleNode
    error: String
    ok: Boolean!
}

type QAAddAnswerReaction {
    answer: QAAnswerNode!
}

"Collection Views"
type QAAddFavAnswer {
    answer: QAAnswerNode!
}

type QAAnswerConnection {
    "Contains the nodes in this connection."
    edges: [QAAnswerEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `QAAnswer` and its cursor."
type QAAnswerEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: QAAnswerNode
}

type QAAnswerList {
    nextToken: String
    nodes: [QAAnswerNode!]!
}

type QAAnswerNode {
    articleType: ArticleType!
    author: UserNode!
    byLeetcode: Boolean!
    canEdit: Boolean!
    chargeType: ArticleChargeEnum!
    content: String!
    createdAt: DateTime!
    flagResult: FlagResultNode
    hasVideo: Boolean!
    hitCount: Int!
    identifier: String!
    isEditorsPick: Boolean!
    isMyFavorite: Boolean!
    nextArticle: ID
    parent: QAQuestionNode
    pinned: Boolean!
    pinnedGlobally: Boolean!
    prevArticle: ID
    reactedType: ArticleReactions
    reactionType: ReactionTypeEnum
    reactions: [ArticleReactionCountNode!]
    reactionsV2: [ReactionCountNode!]
    resourceType: ResourceTypeEnum!
    score: Float
    slug: String! @deprecated(reason : "For reporting purposes only")
    status: ArticleStatus!
    summary: String!
    sunk: Boolean
    thumbnail: String!
    topic: TopicNode
    updatedAt: DateTime
    upvoteCount: Int!
    upvoted: Boolean!
    uuid: ID!
    videosInfo: [VideoInfoNode!]
}

type QABriefQuestionNode {
    title: String!
    uuid: ID!
}

type QADeleteAnswer {
    answer: QAAnswerNode!
}

type QADeleteQuestion {
    question: QAQuestionNode!
}

type QAEditAnswer {
    answer: QAAnswerNode!
}

type QAEditQuestion {
    question: QAQuestionNode!
}

type QAPublishAnswer {
    answer: QAAnswerNode!
}

type QAPublishQuestion {
    question: QAQuestionNode!
}

type QAQuestionAnswerList {
    nextToken: String
    nodes: [QAQuestionAnswerNode!]!
    totalNum: Int!
}

type QAQuestionConnection {
    "Contains the nodes in this connection."
    edges: [QAQuestionEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `QAQuestion` and its cursor."
type QAQuestionEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: QAQuestionNode
}

type QAQuestionNode {
    alwaysExpand: Boolean!
    alwaysShow: Boolean!
    answered: Boolean
    articleType: ArticleType!
    author: UserNode!
    byLeetcode: Boolean!
    canEdit: Boolean!
    chargeType: ArticleChargeEnum!
    content: String!
    createdAt: DateTime!
    flagResult: FlagResultNode
    hasVideo: Boolean!
    hitCount: Int!
    identifier: String!
    isEditorsPick: Boolean!
    isMyFavorite: Boolean!
    myAnswerId: ID
    numAnswers: Int!
    numPeopleInvolved: Int!
    numSubscribed: Int!
    pinned: Boolean!
    pinnedGlobally: Boolean!
    reactedType: ArticleReactions
    reactionType: ReactionTypeEnum
    reactions: [ArticleReactionCountNode!]
    reactionsV2: [ReactionCountNode!]
    resourceType: ResourceTypeEnum!
    score: Float
    slug: String! @deprecated(reason : "For reporting purposes only")
    status: ArticleStatus!
    subject: SubjectNode
    subscribed: Boolean!
    summary: String!
    sunk: Boolean
    tags: [CommonTagNode!]!
    thumbnail: String!
    title: String!
    updatedAt: DateTime
    upvoteCount: Int!
    upvoted: Boolean!
    uuid: ID!
    videosInfo: [VideoInfoNode!]
}

type QARemoveAnswerReaction {
    answer: QAAnswerNode!
}

type QARemoveFavAnswer {
    answer: QAAnswerNode!
}

type QARequestToDeleteQuestion {
    ok: Boolean!
}

type QASetAnswerAsEditorsPick {
    answer: QAAnswerNode!
}

type QASetQuestionAsByLeetcode {
    question: QAQuestionNode!
}

type QASetQuestionMetaData {
    question: QAQuestionNode!
}

type QATogglePinAnswerInQuestion {
    answer: QAAnswerNode!
}

type QATogglePinQuestionGlobally {
    question: QAQuestionNode!
}

type QATogglePinQuestionInCategory {
    question: QAQuestionNode!
}

type QAToggleSubscribeQuestion {
    question: QAQuestionNode!
}

type QAToggleSunk {
    questionAnswer: QAQuestionAnswerNode!
}

type QAUpvoteAnswer {
    answer: QAAnswerNode!
}

type Query {
    achievement(name: String!): AchievementNode
    achievements: [AchievementNode]
    activityConfig(userSlug: String!, verb: VerbType): [ConfigNode!]
    adPics(kind: AdPictureType!): [AdPicNode!]!
    addresses(orderId: String): [DeliveryAddressNode!]!
    allAppliedQuestionTranslations(lang: String): [AppliedTranslationNode!]
    allComments(endDate: DateTime, numPerPage: Int, orderBy: String, pageNo: Int, startDate: DateTime, status: PostStatusEnum, username: String): PagifiedCommentNode
    allContests: [ContestNode!]
    allContributions(category: String, company: Boolean, numPerPage: Int, page: Int, status: String, title: String, user: String): PagifiedContributionNode
    allIndustries: [[String]]
    allLanguageInfo: [LibraryLanguageNode]
    allLeetcodePlaygroundTemplates: [PlaygroundTemplateNode!]
    allPlaygroundCodes(uuid: String): [PlaygroundCodeNode!]
    allPlaygroundDatasets: [PlaygroundDatasetNode!]
    allPlaygroundFolders: [PlaygroundFolderNode!]
    allPlaygroundSnippets(langSlug: String, query: String): [PlaygroundSnippetNode!]
    allPlaygrounds: [PlaygroundNode!]
    allPrivateContests: [ContestNode!]
    allProgress: JSONString
    allQuestionInfo(containContest: Boolean, containExplore: Boolean, containMain: Boolean, containPremium: Boolean): [QuestionInfoNode]
    allQuestionSolutions(containContest: Boolean, containExplore: Boolean, containMain: Boolean, containPremium: Boolean): [QuestionSolutionNode]
    allQuestionTranslations(isPending: Boolean, numPerPage: Int, pageNo: Int, titleSlug: String): PagifiedTranslationNode
    allQuestionUrls(containMain: Boolean): QuestionURLNode
    allQuestions(containContest: Boolean, containExplore: Boolean, containMain: Boolean, containPremium: Boolean): [QuestionNode!]
    allQuestionsBeta(containContest: Boolean, containExplore: Boolean, containMain: Boolean, containPremium: Boolean): [QuestionNode!]
    allReportedPosts(numPerPage: Int, pageNo: Int, reportType: ReportTypeEnum, showHandled: Boolean, username: String): PagifiedPostNode
    allSchoolInfoUrl: String!
    allSolutionArticles(
        after: String,
        before: String,
        filterTags: [String],
        first: Int,
        last: Int,
        orderBy: ArticleOrderBy,
        skip: Int
    ): SolutionArticleConnection!
    allTopics(endDate: DateTime, numPerPage: Int, orderBy: TopicSortingOption, pageNo: Int, startDate: DateTime, status: PostStatusEnum, username: String): PagifiedTopicNode
    allUnhandledQuestions: [QuestionNode!]
    allUserPlaygroundTemplates: [PlaygroundTemplateNode!]
    allUsers(avatarStatus: AvatarStatusEnum, endDate: DateTime, isAvatarCheck: Boolean, numPerPage: Int, pageNo: Int, startDate: DateTime): PagifiedUserNode
    allVirtualContestScores: [VirtualContestScoreNode!]
    announcements: [DiscussAnnouncementNode!]!
    application(id: ID): ApplicationNode
    applications: [ApplicationNode!]
    appliedQuestionTranslation(lang: String, titleSlug: String!): AppliedTranslationNode
    article(id: String): ArticlePageNode
    articlesFeedbackList(after: String, before: String, first: Int, last: Int, skip: Int): ArticleFeedbackConnection!
    blacklist: BlacklistNode
    blockingBlockedArticles(
        articleType: ArticleType!,
        pageNumber: Int,
        resultPerPage: Int
    ): BlockedArticleListNode!
    blockingBlockedUsers(
        pageNumber: Int,
        resultPerPage: Int
    ): BlockedUserListNode!
    brightTitle: Boolean
    card(cardSlug: String): CardNode
    cardGroup(groupSlug: String!): CardGroupNode
    cardGroups: [CardGroupNode!]
    cards(categorySlug: String): [CardNode!]
    cardsWithStats: [CardNode!]
    categories(slug: String): [CategoryNode!]
    categoryTopicList(after: String, before: String, categories: [String], first: Int, last: Int, orderBy: TopicSortingOption, query: String, skip: Int, tags: [String]): TopicConnection
    channels: [ChannelNode]
    chapter(cardSlug: String, chapterId: String): ChapterNode
    chapters(cardSlug: String): [ChapterNode!]
    chinaHost: String
    chinaLocation: JSONString
    cnTopicComments(after: String, before: String, first: Int, last: Int, orderBy: CnCommentSortEnum, skip: Int, thresholdVoteNumber: Int, topicId: Int!): CommentConnection
    columnsAnyArticles(after: String, before: String, first: Int, last: Int, query: String!, skip: Int, userSlug: String!): ColumnArticleConnection!
    columnsArticleById(uuid: ID!): ColumnArticleNode
    columnsArticleSuggestionOptions(
        after: String,
        before: String,
        filterTagSlugs: [String!],
        first: Int,
        last: Int,
        query: String!,
        skip: Int,
        subjectSlug: String
    ): ColumnArticleConnection!
    columnsArticleTags(query: String, selectedTagSlugs: [String!]): ColumnArticleTagListNode!
    columnsArticles(
        after: String,
        before: String,
        filterTagSlugs: [String!],
        first: Int,
        last: Int,
        orderBy: ArticleOrderBy,
        skip: Int,
        subjectSlug: String!
    ): ColumnArticleConnection!
    columnsBriefHotArticles: [ColumnArticleNode!]!
    columnsDraft(
        uuid: ID!
    ): ColumnArticleNode
    columnsExternalImgHostWhitelist: [String!]!
    columnsFavoriteArticles(after: String, before: String, first: Int, last: Int, query: String!, skip: Int): ColumnArticleConnection!
    columnsHotArticles(filterTagSlugs: [String!], limit: Int, orderBy: ArticleOrderBy, skip: Int, subjectSlug: String): ColumnArticleListNode!
    columnsMyArticles(after: String, before: String, first: Int, last: Int, query: String!, skip: Int): ColumnArticleConnection!
    columnsMyDrafts(after: String, before: String, first: Int, last: Int, skip: Int): ColumnArticleConnection!
    columnsMySubscriptionList(after: String, before: String, first: Int, last: Int, query: String, skip: Int): ColumnArticleConnection!
    comment(id: Int): CommentNode
    commentContext(commentId: Int, numPerPage: Int, orderBy: String, topicId: Int): JSONString
    commentPage(
        commentId: ID!,
        numPerPage: Int,
        orderBy: CommentOrderBy,
        replyNumPerPage: Int,
        replyOrderBy: CommentReplyOrderBy
    ): CommentWithReplyPageInfoNode
    commentPageInfo(commentId: ID!, numPerPage: Int, orderBy: CommentOrderBy): CommentPageInfoNode
    commentReplies(commentId: Int): [CommentNode!]
    commentReplyConnection(after: String, before: String, commentId: ID, first: Int, last: Int, orderBy: CommentReplyOrderBy, skip: Int): CommentConnection
    commentsSelection(topicId: ID!): [CommentRelayNode]
    commonTags(query: String, slugs: [String!]): [CommonTagNode!]!
    commonTopicComments(after: String, before: String, first: Int, last: Int, orderBy: CommentOrderBy, skip: Int, topicId: Int!): CommentConnection
    communityBriefHotTopics: [CommunityTopicBriefNode!]!
    communityHotTopics(filterTagSlugs: [String!], limit: Int, orderBy: TopicOrderBy, skip: Int): CommunityHotTopicListNode!
    communityMyComments(after: String, before: String, first: Int, last: Int, query: String, skip: Int): CommentConnection!
    communityMyFavoriteTopics(after: String, before: String, first: Int, last: Int, query: String, skip: Int): CommunityTopicConnection!
    communityMyStatus: CommunityStatusNode!
    communityMySubscribedTopics(after: String, before: String, first: Int, last: Int, query: String, skip: Int): CommunityTopicConnection!
    communityMyTopics(after: String, before: String, first: Int, last: Int, query: String, skip: Int): CommunityTopicConnection!
    communityRecommendedItems(
        filterTagSlugs: [String],
        nextToken: String,
        query: String,
        subjectSlug: String
    ): CommunityItemListNode!
    communityTags(query: String, selectedTagSlugs: [String!]): CommunityTagListNode!
    communityTopic(id: ID!): CommunityTopicNode
    communityTopicSuggestionOptions(
        after: String,
        before: String,
        filterTagSlugs: [String!],
        first: Int,
        last: Int,
        query: String!,
        skip: Int,
        subjectSlug: String
    ): CommunityTopicConnection!
    communityTopics(
        after: String,
        before: String,
        filterTagSlugs: [String!],
        first: Int,
        last: Int,
        orderBy: TopicOrderBy,
        skip: Int,
        subjectSlug: String!
    ): CommunityTopicConnection!
    companies(search: String): [CompanyNode!]
    companyTag(slug: String): CompanyTagNode
    companyTagInfo(slug: String): CompanyTagInfoNode
    companyUser(id: ID!): CompanyUserNode
    companyUserCandidates(after: String, before: String, first: Int, keyword: String, last: Int, skip: Int): CompanyUserCandidateConnection
    companyUsers: [CompanyUserNode]
    contest(titleSlug: String): ContestNode
    contestGroup(slug: String!): ContestGroupNode
    contestGroupRegistrationInfo: ContestGroupRegistrationInfoNode
    contestGroupSchoolStats(contestGroupSlug: String!): [ContestGroupSchoolStatsNode!]!
    contestTopics(contestTitleSlug: String, numPerPage: Int, orderBy: TopicSortingOption, pageNo: Int): PagifiedTopicNode
    contribution(id: ID): ContributionNode
    contributions: [ContributionNode!]
    cooperationPartners: [CooperationPartnerNode]
    currentContestAnnouncements: [ContestAnnouncementNode!]
    dashboardItem(id: String): ItemNode
    discount(id: ID!): DiscountNode
    discussCategory(slugs: [String]): DiscussCategoryNode
    discussQuestionTopicTags(numTags: Int, questionId: String, selectedTags: [String], tagType: String): [DiscussTopicTagNode!]!
    educationRecordList: [EducationRecordNode!]
    emailEvent(id: Int): EmailEventNode
    emailEvents: [EmailEventNode!]
    emailSendSession(id: Int): EmailSendSessionNode
    emailSendSessions: [EmailSendSessionNode!]
    emailTemplate(id: Int): EmailTemplateNode
    emailTemplates: [EmailTemplateNode!]
    enableAppCodeEditor: Boolean!
    eventMerchandisePrize(uniqueId: ID!): UserMerchandiseEventNode
    examAccountSessions(uuid: UUID!): [ExamAccountParticipationNode!]!
    examGetAccountExamQuizzesReply(accountUuid: ID!, examId: ID!): ExamQuizzesReplyNode!
    examGetBasicExam(examId: ID!): BasicExamNode
    examGetExam(examId: ID!): ExamNode
    examGetExamList(
        ended: Boolean,
        started: Boolean
    ): [ExamNode!]!
    examGetExamTemplate(uuid: UUID!): ExamTemplateNode
    examGetMyExamQuizzesReply(examId: ID!): ExamQuizzesReplyNode!
    examGetMySession(examId: ID!): ExamSessionNode
    examGetSampleFile(fileType: ExamSampleFileEnum!): String!
    examListExamTemplates: [ExamTemplateNode!]!
    examQuestionSubmissions(
        accountId: ID,
        examId: ID!,
        questionId: ID!
    ): [ExamSubmissionNode!]!
    examQuestions(ownership: QuestionOwnershipEnum!): [ExamQuestionOptionNode!]!
    examQuizzes(sourceType: SourceTypeEnum!): [ExamQuizOptionNode!]!
    examRecord(
        #company account uuid
        accountId: ID!,
        #exam display id
        displayId: ID!
    ): RecordNode
    examReport(examId: ID!): ExamReportNode
    examSessionDetail(accountId: ID!, examId: ID!): ExamSessionNode
    examSubmission(submissionId: ID!): ExamSubmissionNode
    favorite(name: String!): FavoriteNode
    favoriteCards: [CardNode!]
    favoriteSubscriptionProblemList(numPerPage: Int, pageNum: Int, userSlug: String): ProblemSubscribedNode!
    favoritesLists: FavoritesNode
    feature: FeatureNode
    """
    | verb | actor | obj | target |

    ** Discussion **
    1. USER_PUBLISH_QAANSWER UserNode FeedArticleNode UserNode

    2. COMMENT_QAANSWER UserNode FeedArticleCommentNode UserNode

    3. UPVOTE_QAANSWER UserNode FeedArticleNode UserNode

    4. SUBSCRIBE_QAQUESTION UserNode FeedArticleNode UserNode

    5. USER_PUBLISH_QAQUESTION UserNode FeedArticleNode UserNode


    ** Article **
    1. USER_ADD_ARTICLE UserNode FeedArticleNode [None]

    2. COLLECT_ARTICLE UserNode FeedArticleNode [None]

    3. UPVOTE_ARTICLE UserNode FeedArticleNode [None]

    4. SUBSCRIBE_ARTICLE UserNode FeedArticleNode [None]

    5. COMMENT_ARTICLE UserNode FeedArticleCommentNode [None]
    """
    feedV2(
        pageNumber: Int,
        resultPerPage: Int,
        subType: ActivitySubType!,
        userSlug: String!
    ): ActivityInfoNode!
    feedbackReasons: [FeedbackReasonNode!]
    fieldPermissionInfos(
        namespaces: [ResolverNamespaceEnum!]!
    ): [FieldPermissionInfoNode!]!
    filteredSubmissions(inputFilters: String, numPerPage: Int, pageNo: Int): [FilteredSubmissionNode]
    flagReasons(resourceType: ResourceTypeEnum): [FlagReasonNode!]!
    flagResourceType(name: ResourceTypeEnum!): ResourceTypeNode
    followers(pageNumber: Int, resultPerPage: Int, userSlug: String!): FollowUsersNode
    following(pageNumber: Int, resultPerPage: Int, userSlug: String!): FollowUsersNode
    globalRanking(page: Int): GlobalRankingNode
    grantedPremiumRecords(data: GrantedPremiumRecordsInput): [GrantedPremiumRecordNode!]!
    historyCards: [CardNode!]
    htmlArticle(id: String): HtmlArticleNode
    internalContestAwardedUsers(contestSlug: String): [Int]
    internalContestFeedbackEmail: String
    internalContestRegisterEmail: String
    interviewAllSessions(after: String, before: String, first: Int, last: Int, skip: Int): InterviewSessionConnection!
    interviewCard(companySlug: String!): InterviewCardNode
    interviewCardCompleted(cardId: ID!): Boolean
    interviewCardList: [InterviewCardNode!]
    interviewCardSuggestions(query: String!): [InterviewCardNode!]!
    interviewCompanyOptions(query: String): [InterviewCompanyOption!]!
    interviewCompanySessions(after: String, before: String, first: Int, last: Int, skip: Int): InterviewSessionConnection!
    interviewCreateCardsSucceeded(taskId: String!): Boolean!
    interviewCurrentSession: InterviewSessionNode
    "returns at most 9 cards"
    interviewHotCards(onlyCompanyCards: Boolean): [InterviewCardNode!]!
    interviewHotSearchHistory: [InterviewCardNode!]!
    interviewMyFavCards: [InterviewCardNode!]!
    interviewOpenedCards: [InterviewCardNode!]!
    interviewSearchHistory: [InterviewCardNode!]!
    interviewSession(id: ID!): InterviewSessionNode
    interviewSessions(after: String, before: String, cardId: ID!, first: Int, last: Int, skip: Int): InterviewSessionConnection
    interviewSubmissions(after: String, before: String, first: Int, last: Int, questionId: ID!, sessionId: ID!, skip: Int): InterviewSubmissionConnection!
    interviewed: InterviewSurveyNode
    isCurrentUserAuthenticated: Boolean
    isQuestionInFavoriteLists(questionId: ID!): [AnnotatedFavoriteListNode!]!
    item(id: String): ItemNode
    items(chapterSlug: String): [ItemNode!]
    jobApplication(applicationId: ID): JobApplicationNode
    jobApplications(after: String, before: String, first: Int, jobId: ID, last: Int, skip: Int): JobApplicationConnection
    jobInvitations(after: String, before: String, first: Int, last: Int, orderByInvitedTime: Int, skip: Int, userSlug: String): JobInvitationConnection
    jobPosting(jobId: String): JobPostingNode
    jobPostings(after: String, before: String, companySlug: String, first: Int, last: Int, showExpired: Boolean, skip: Int): JobPostingConnection
    jobPromotionApplications(after: String, before: String, first: Int, hasApplied: Boolean, last: Int, promotionId: ID!, skip: Int): JobPromotionApplicationConnection
    jobPromotionApplicationsExportTask(hasApplied: Boolean, promotionId: ID!): ExportTask
    jobPromotions(after: String, before: String, first: Int, last: Int, skip: Int): JobPromotionConnection
    jobsChoices(fieldName: String!): [[String]]
    jobsCompanies: [JobsCompanyNode]
    jobsCompany(companySlug: String): JobsCompanyNode
    jobsTemplateFiles(fileTypes: [TemplateFileEnum]): JSONString
    jobsUserInvitationSetting(userSlug: String!): UserInvitationSettingNode
    languageList: [LanguageNode]
    localRanking(page: Int): LocalRankingNode
    locationDict: JSONString
    loginSocial: [SocialLoginNode]
    loginUrl: String
    managementAdminLogs(first: Int!, skip: Int!, userSlug: String!): AdminLogContentNodeList!
    managementArticleFlags(first: Int!, orderBy: SortingOrderEnum, skip: Int!, uuid: ID!): ArticleFlagDetail!
    managementArticlesReviews(first: Int!, skip: Int!, status: HandledReviewStatusType!): ReviewContentListNode!
    managementBannedUsers(
        after: String,
        before: String,
        first: Int,
        last: Int,
        skip: Int,
        status: UserBannedStatus,
        userName: String
    ): BannedUserNodeConnection
    managementCommentFlags(first: Int!, id: Int!, orderBy: SortingOrderEnum, skip: Int!): CommentFlagDetail
    managementCommentsReviews(first: Int!, skip: Int!, status: HandledReviewStatusType!): ReviewContentListNode!
    managementDeletionRequests(after: String, before: String, first: Int, last: Int, orderBy: SortingOrderEnum, skip: Int, sortField: RequestObjectSortFieldEnum, status: RequestObjectStatusEnum!): ArticleDeletionRequestConnection!
    managementFeaturedRequests(first: Int!, skip: Int!, status: HandledStatusType!): FeaturedRequestListNode
    managementFlaggedArticles(after: String, before: String, first: Int, last: Int, orderBy: SortingOrderEnum, skip: Int, sortField: FlaggableObjectSortFieldEnum, status: FlagStatus!): FlaggedArticleConnection!
    managementFlaggedComments(
        after: String,
        before: String,
        first: Int,
        last: Int,
        orderBy: SortingOrderEnum,
        skip: Int,
        sortField: FlaggableObjectSortFieldEnum,
        status: FlagStatus!,
        targetType: CommentTargetType!
    ): FlaggedCommentConnection
    managementRemovedComments(
        after: String,
        before: String,
        first: Int,
        last: Int,
        orderBy: SortingOrderEnum,
        skip: Int,
        sortField: FlaggableObjectSortFieldEnum,
        targetType: CommentTargetType!
    ): FlaggedCommentConnection
    managementRoles(
        roleName: String
    ): [NOJRoleNode]!
    managementSubjects(
        keywords: String
    ): [SubjectNode!]!
    managementUsers(
        first: Int!,
        skip: Int!,
        userName: String
    ): UserListNode!
    matchedUsers(limit: Int, namePrefix: String!, topicId: Int): [UserNode!]
    mostRecentCard: CardNode
    myEventMerchandisePrize(eventSlug: ID!): UserMerchandiseEventNode
    myFavSolutionArticles: FavoriteListNode
    myJobApplications(after: String, before: String, first: Int, jobId: ID, last: Int, skip: Int): JobApplicationConnection
    """
    verb actor obj target

    ** Discussion **
    1. UPDATE_QAQUESTION UserNode FeedArticleNode [None]

    2. QAQUESTION_ADD_ANSWER UserNode FeedArticleNode UserNode

    3. COMMENT_QAANSWER UserNode FeedArticleCommentNode UserNode

    4. USER_PUBLISH_QAANSWER UserNode FeedArticleNode UserNode

    5. REPLY_QAANSWER_COMMENT UserNode FeedArticleCommentNode UserNode

    6. QAQUESTION_REFER UserNode FeedArticleNode UserNode

    7. QAANSWER_REFER UserNode FeedArticleNode UserNode

    8. UPVOTE_QAANSWER_COMMENT UserNode FeedArticleCommentNode UserNode

    9. SUBSCRIBE_QAQUESTION UserNode FeedArticleNode UserNode

    10. ACCEPT_DELETE_QAQUESTION UserNode FeedArticleNode UserNode

    11. REJECT_DELETE_QAQUESTION UserNode FeedArticleNode UserNode


    ** Articles **
    1. COMMENT_ARTICLE UserNode FeedArticleCommentNode [None]

    2. UPVOTE_ARTICLE UserNode FeedArticleNode [None]

    3. REPLY_ARTICLE_COMMENT UserNode FeedArticleCommentNode [None]

    4. UPVOTE_ARTICLE_COMMENT UserNode FeedArticleCommentNode [None]

    5. ARTICLE_COMMENT_REFER UserNode FeedArticleCommentNode [None]

    6. ARTICLE_REFER UserNode FeedArticleNode [None]

    7. COMMENT_ARTICLE_AGG FeedArticleCommentNode FeedArticleNode UserNode


    ** Community **
    1. DELETE_ARTICLE UserNode FeedArticleNode UserNode

    2. DELETE_COMMENT UserNode ProblemCommentNode UserNode

    3. DELETE_COMMENT UserNode FeedArticleCommentNode UserNode


    1. BAN_USER UserNode BannedUserNode UserNode
    """
    myNotificationV2(
        pageNumber: Int,
        resultPerPage: Int,
        subType: ActivitySubType!
    ): ActivityInfoNode!
    myOrders(after: ID, limit: Int): [OrderNode]
    myPlaygroundState: UserPlaygroundStateNode
    myUnreadNotificationNum(subType: ActivitySubType): Int!
    nextChallengePairs(titleSlug: String): JSONString
    notification(id: Int): NotificationNode
    notificationActivity(uuid: UUID!): ActivityNode
    notificationCategories: [NotificationCategoryNode]
    notificationConfigurableTypes: [NotificationConfigurableTypeNode!]!
    notificationStatus: JSONString
    notificationTypes: [NotificationTypeNode]
    notificationUnifiedSettings: NotificationUnifiedSettingsNode
    notifications(
        after: String,
        before: String,
        endTime: Float,
        first: Int,
        last: Int
    ): NotificationConnection
    occupationRecordList: [OccupationRecordNode!]
    ongoingContestGroup: ContestGroupNode
    order(orderId: ID!): OrderNode
    orderPaid(orderId: ID!): Boolean
    ordersByDiscount(discountId: ID!): [OrderNode!]
    ordersByEvent(eventSlug: ID!): [OrderNode!]
    playground(uuid: String): PlaygroundNode
    playgroundCode(langSlug: String, uuid: String): PlaygroundCodeNode
    playgroundSnippet(functionName: String, langSlug: String): PlaygroundSnippetNode
    playgroundTemplate(templateId: String): PlaygroundTemplateNode
    pointList(page: Int): PointListNode
    pollInterval: Int
    post(id: Int): PostNode
    privateContestAllParticipants: [PrivateContestUserNode!]
    privateContestRegisteredUserIds(contestSlug: String): [ID]
    problemsetCategories: [ProblemSetCategoryTypeNode!]!
    problemsetCategory(slug: String!): CategoryInfoNode
    product(slug: String!): ProductNode
    products(data: ProductByCategoryInput!): [ProductNode]
    publicOrder(orderId: ID!): PublicOrderNode
    qaAnswer(
        orderBy: QAAnswerListOrderEnum,
        uuid: ID!
    ): QAAnswerNode
    qaAnswerList(nextToken: String, orderBy: QAAnswerListOrderEnum, questionId: ID!): QAAnswerList!
    qaAnyAnswers(after: String, before: String, first: Int, last: Int, skip: Int, userSlug: String!): QAAnswerConnection
    qaAnyQuestions(after: String, before: String, first: Int, last: Int, skip: Int, userSlug: String!): QAQuestionConnection
    qaBriefHotQuestions: [QABriefQuestionNode!]!
    qaCommunityTags(query: String, selectedTagSlugs: [String!]): ColumnArticleTagListNode!
    qaMyAnswers(after: String, before: String, first: Int, last: Int, skip: Int): QAAnswerConnection
    qaMyFavoriteAnswers(after: String, before: String, first: Int, last: Int, query: String, skip: Int): QAAnswerConnection!
    qaMyQuestions(after: String, before: String, first: Int, last: Int, skip: Int): QAQuestionConnection
    qaMySubscriptionList(numPerPage: Int, pageNum: Int): [QAQuestionNode!]!
    qaQuestion(uuid: ID!): QAQuestionNode
    qaQuestionAnswerList(
        filterTagSlugs: [String!],
        limit: Int,
        nextToken: String,
        orderBy: QAOrderEnum,
        query: String,
        subjectSlug: String
    ): QAQuestionAnswerList!
    qaQuestionTags(query: String, selectedTagSlugs: [String!]): ColumnArticleTagListNode!
    question(titleSlug: String): QuestionNode
    questionSolutionArticles(after: String, before: String, first: Int, last: Int, orderBy: SolutionArticleOrderBy, questionSlug: String!, skip: Int, userInput: String): SolutionArticleConnection!
    questionSolutionVideoArticles(after: String, before: String, first: Int, last: Int, orderBy: SolutionArticleOrderBy, questionSlug: String!, skip: Int, userInput: String): SolutionArticleConnection!
    questionTag(tagId: ID!): QuestionTagNode
    questionTagsAdmin(tagType: TagTypeEnum!): [QuestionTagNode!]
    questionTagsSuggest(search: String): [String]
    questionTopicTags(after: String, before: String, first: Int, last: Int, skip: Int): TopicTagConnection
    questionTopics(numPerPage: Int, orderBy: TopicSortingOption, pageNo: Int, query: String, questionId: Int): PagifiedTopicNode
    questionTranslation(id: Int, titleSlug: String): TranslationNode
    questionsFeedbackList(after: String, before: String, first: Int, last: Int, skip: Int): QuestionFeedbackConnection!
    quizGetQuiz(uid: String!): QuizNode
    quizSampleFile(fileType: QuizSampleFileTypeEnum!): String!
    rawCharge(orderId: ID!): String
    recentSubmissions(userSlug: String!): [FeedSubmissionNode!]!
    roles: [RoleNode!]!
    rootCategory: [DiscussCategoryNode!]!
    schools(search: String): [SchoolNode!]
    siteRegion: String
    skillTags(search: String): [SkillTagNode!]
    solutionArticle(articleId: String, orderBy: SolutionArticleOrderBy, slug: String): SolutionArticleNode
    solutionArticleToEdit(slug: String!): SolutionArticleNode
    solutionArticles(after: String, before: String, first: Int, last: Int, skip: Int, userSlug: String!): SolutionArticleConnection!
    solutionArticlesByLeetcode(after: String, before: String, first: Int, last: Int, orderBy: ArticleOrderBy, query: String, skip: Int): SolutionArticleConnection!
    solutionDrafts(after: String, before: String, first: Int, last: Int, questionSlug: String, skip: Int): SolutionArticleConnection!
    solutionNum(questionSlug: String!): Int!
    statusList: [SubmissionStatusNode]
    storageInfo(taskId: String!): ExportResultNode
    storeMerchandiseList: [MerchandiseNode!]
    storeMerchandiseListForSale: [MerchandiseNode!]
    subjects: [SubjectNode!]!
    subjectsMine: [SubjectNode!]!
    submissionCheckState(submissionId: String!): JSONString!
    submissionList(lastKey: String, limit: Int, offset: Int, questionSlug: String): SubmissionListNode
    submissionMySubmission(submissionId: ID!): SubmissionNode
    subscribeUrl: String
    tags(query: String, tagTypes: [TagTypeEnum!]!): [TagNode!]!
    timestamp: DateTime!
    topic(id: Int): TopicNode
    topicComments(numPerPage: Int, orderBy: String, pageNo: Int, topicId: Int!): PagifiedCommentNode
    topicTag(slug: String): TopicTagNode
    topicTags(categorySlugs: [String], numTags: Int, selectedTags: [String], tagType: String): [DiscussTopicTagNode!]!
    topicTagsSuggest(search: String): [DiscussTopicTagNode!]!
    ugcIsLibraryAdmin: Boolean!
    ugcMyOrganizations(
        after: String,
        before: String,
        first: Int,
        last: Int,
        search: String,
        skip: Int
    ): ContributionOrganizationConnection!
    ugcOrganization(organizationId: ID!): ContributionOrganizationNode
    ugcOrganizations(
        after: String,
        before: String,
        first: Int,
        last: Int,
        search: String,
        skip: Int
    ): ContributionOrganizationConnection!
    ugcPreviewSolution(solutionId: ID!, submitId: String!, ugcQuestionId: String!): UGCJudgeResultNode!
    ugcQuestion(ugcQuestionId: String!): UGCQuestionV2Node!
    ugcQuestionAdminLogs(
        after: String,
        before: String,
        first: Int,
        last: Int,
        skip: Int,
        ugcQuestionId: String!
    ): UGCQuestionAdminLogConnection!
    ugcQuestionCategories(
        search: String
    ): [UGCQuestionCategoryNode!]!
    ugcQuestionGenerateOutput(submitId: String!, ugcQuestionId: String!): UGCGenerateOutputResultNode!
    ugcQuestionInterpretSolution(submitId: String!, ugcQuestionId: String!): UGCGenerateOutputResult!
    ugcQuestionList(
        category: String,
        difficulty: Difficulty,
        filteredIndividual: String,
        filteredOrganization: String,
        isDraft: Boolean,
        isPrivate: Boolean,
        orderBy: SortingOrderEnum!,
        pageSize: Int!,
        skip: Int!,
        sortField: UGCQuestionSortFieldEnum!
    ): UGCQuestionsNode!
    ugcQuestionTags(
        search: String
    ): [CommonTagNode!]!
    user: UserNode
    userBannedInfo: UserBannedInfoNode!
    userHasPassword: Boolean
    userPermissions: UserPermissionNode!
    userProfilePublicProfile(userSlug: String!): PublicProfileNode
    userProfileQuestions(difficulty: [DifficultyEnum!], first: Int!, keyword: String, skip: Int!, sortField: SortFieldEnum!, sortOrder: SortingOrderEnum!, status: StatusFilterEnum!): ProgressQuestionListNode
    userProfileSessionProgress: SessionProgressNode
    userReports(endDate: DateTime, handled: Boolean, numPerPage: Int, pageNo: Int, startDate: DateTime): PagifiedUserReportNode
    userStatus: MeNode
    users(usernamePrefix: String): [UserNode!]
    usersWithPermission(permissionEnumName: String): [UserNode!]
    video(id: String): VideoNode
    videosVideoInfo(fetchType: VideoFetchInfoType, uuid: UUID!): VideosVideoNode
    voteStats(slug: String!): VoteSubjectNode
    votes(topicId: Int): JSONString
    webPage(id: String): WebPageNode
    websocketUrl: String
    wikiEntry(
        slug: String!,
        tagType: TagTypeEnum!
    ): WikiEntryNode!
    worldCities(country: String, subcountry: String): [String]
    worldCountries: [String]
    worldSubcountries(country: String): [String]
}

type QuestionCountNode {
    count: Int!
    difficulty: DifficultyEnum!
}

type QuestionDataNode {
    category: UGCQuestionCategoryNode!
    codeDefinitions: JSONString
    customLimits: JSONString
    customMatcher: String
    descriptionCn: String
    descriptionUs: String
    difficulty: Difficulty!
    displayId: String!
    drivers: JSONString
    inputSchema: String
    isPrivate: Boolean
    matchType: MatchType!
    outputSchema: String
    publishedDate: DateTime
    questionType: QuestionTypeEnum!
    sampleTestcase: String
    solutions: [SolutionNode!]!
    tags: [CommonTagNode!]!
    testcaseInFile: String
    testcaseOutFile: String
    titleCn: String!
    titleUs: String
}

type QuestionFeedbackConnection {
    "Contains the nodes in this connection."
    edges: [QuestionFeedbackEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `QuestionFeedback` and its cursor."
type QuestionFeedbackEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: QuestionFeedbackNode
}

type QuestionFeedbackNode {
    createdAt: DateTime!
    detail: String!
    feedbackReasons: [FeedbackReasonNode!]!
    id: ID!
    modifiedAt: DateTime!
    question: QuestionNode!
    status: ArticleFeedbackStatus!
    user: UserNode!
}

type QuestionInfoNode {
    frequency: Float!
    questionId: ID!
    solutionsNum: Int!
}

type QuestionNode {
    allowDiscuss: Boolean
    article: JSONString
    articleTopicId: String
    book: CategoryInfoNode
    boundTopicId: Int
    categoryTitle: String
    codeDefinition: JSONString
    codeSnippets: [CodeSnippetNode]
    companyTagStats(after: String, timeRange: TagFreqRange): JSONString
    content: String
    contributors: [ContributorNode!]
    difficulty: String
    dislikes: Int
    enableRunCode: Boolean
    enableSubmit: Boolean
    enableTestMode: Boolean
    envInfo: JSONString
    frequencyTimePeriod: Int
    hints: [String]
    infoVerified: Boolean
    interpretUrl: String
    isLiked: Boolean
    isPaidOnly: Boolean
    isSubscribed: Boolean!
    judgeType: String
    judgerAvailable: Boolean
    langToValidPlayground: JSONString
    libraryUrl: String
    likes: Int
    metaData: String
    mysqlSchemas: [String]
    nextChallengePairs(questionId: String): JSONString
    note: String
    questionDetailUrl: String
    questionFrontendId: String
    questionId: String
    questionTitle: String
    questionTitleSlug: String
    questionType: String
    randomQuestionUrl: String
    sampleTestCase: String
    sessionId: String
    similarQuestions: JSONString
    solution: ArticleNode
    stats: JSONString
    status: String
    submitUrl: String
    title: String!
    titleSlug: String!
    topicTags: [TopicTagNode!]
    translatedContent: String
    translatedTitle: String
    ugcQuestionId: String
    urlManager: JSONString
}

type QuestionSolutionNode {
    questionId: ID!
    solutionsNum: Int!
}

type QuestionTagNode {
    createdAt: DateTime!
    id: ID!
    imgUrl: String
    isEnabled: Boolean!
    isPublic: Boolean!
    keywords: [String!]!
    name: String!
    pinyin: [String!]!
    questions: [QuestionTagStatsNode!]!
    slug: String!
}

type QuestionTagStatsNode {
    frontendId: ID!
    id: ID!
    interviewedCount: Int!
    title: String!
}

type QuestionURLNode {
    questionUrl: String!
}

type QuizCategoryNode {
    name: String!
    slug: String!
}

type QuizImportNode {
    answer: String!
    children: [QuizImportNode!]!
    content: String!
    difficulty: QuizDifficultyEnum!
    explanation: String!
    extraColumns: [String!]!
    nonexistentTagNames: [String!]!
    tags: [TagNode!]!
    type: QuizTypeEnum!
}

type QuizImportQuizzes {
    ok: Boolean!
    quizzes: [QuizImportNode!]
}

type QuizNode {
    answer: JSONString!
    category: QuizCategoryNode
    children: [QuizNode!]
    content: String!
    createdAt: DateTime!
    difficulty: QuizDifficultyEnum!
    explanation: String!
    extraContent: JSONString!
    kind: QuizKindEnum!
    modifiedAt: DateTime!
    sourceType: SourceTypeEnum!
    tags: [TagNode]!
    type: QuizTypeEnum!
    uid: String!
}

type RankingNode {
    currentGlobalRanking: Int!
    currentRating: String!
    dataRegion: String
    ranking: String!
    user: UserNode
}

type RateArticle {
    error: String
    ok: Boolean
    scoreResult: Int
}

type RatingNode {
    average: Float!
    count: Int!
    id: ID!
    userRating: UserRatingNode
}

type ReactionCountNode {
    count: Int!
    reactionType: ReactionTypeEnum!
}

type RecordNode {
    recordList: [String!]!
}

type RefundNode {
    amount: Int!
    createdAt: Float!
    description: String!
}

type RegisterContestGroup {
    error: String
    ok: Boolean!
}

type RegisterForContestGroup {
    registrationInfo: ContestGroupRegistrationInfoNode!
}

type RejectContribution {
    error: String
    ok: Boolean
}

type RejectQuestionTranslation {
    error: String
    ok: Boolean
    translation: TranslationNode
}

type RemoveFavArticle {
    article: ArticleUnionNode
    error: String
    ok: Boolean!
}

type RemoveQuestionFromFavorite {
    error: String
    favoriteIdHash: String
    ok: Boolean
    questionId: String
    userName: String
}

type RemoveReaction {
    article: ArticleUnionNode
    error: String
    ok: Boolean!
}

type RemoveUsersFromInternalContest {
    ok: Boolean
}

type ReportInfoNode {
    content: String!
    id: ID!
    isHandled: Boolean
    reportType: String
    reporter: PrivateContestUserNode!
}

type ReportUser {
    error: String
    ok: Boolean
}

type RequestUpdateToReportedPost {
    error: String
    ok: Boolean
}

type ResourceTypeNode {
    flaggedObjects(after: String, before: String, first: Int, last: Int, order: SortingOrderEnum, orderBy: FlaggedObjectListOrderByEnum, skip: Int, status: FlagStatus): FlaggedObjectConnection!
    name: ResourceTypeEnum!
    operations: [FlagStatus!]
}

type ReviewContentDataNode {
    author: UserNode!
    content: String!
    createdAt: DateTime!
    id: ID!
    title: String!
    type: ContentReviewType!
    uri: String!
}

type ReviewContentListNode {
    nodes: [ReviewContentNode]!
    totalNum: Int!
}

type ReviewContentNode {
    contentData: ReviewContentDataNode!
    status: HandledReviewStatusType!
}

type RoleNode {
    desc: String!
    id: ID!
    isDefault: Boolean!
    name: String!
    numAdmins: Int!
    permissionCodes: [Int!]!
    pk: ID!
}

type RunCodeResult {
    interpretExpectedId: ID
    interpretId: ID!
    testCase: String!
}

type SaveOrUpdateAsciiCode {
    error: String
    ok: Boolean!
}

type SaveQuestionSolution {
    question: UGCQuestionV2Node!
}

type SaveTempExportedData {
    error: String
    id: ID
    ok: Boolean!
}

type SchoolNode {
    colloquial: String!
    id: ID!
    name: String!
    slug: String!
}

type ScoreNode {
    category: ScoreCategory!
    date: DateTime!
    description: String!
    extraInfo: String
    id: ID!
    score: Int!
}

type SendArticleFeedback {
    ok: Boolean!
}

type SendInternalContestEmail {
    error: String
    ok: Boolean
}

type SendInvitation {
    error: String
    ok: Boolean!
}

type SendLeetCodeNotification {
    ok: Boolean!
}

type SendQuestionFeedback {
    ok: Boolean!
}

type SendSmsCode {
    ok: Boolean
}

type SendVerificationEmail {
    ok: Boolean
}

type SendVerificationSms {
    error: String
    ok: Boolean
}

type SessionProgressNode {
    name: String!
    numAcSubmissions: Int!
    numAcceptedQuestions: [QuestionCountNode!]!
    numFailedQuestions: [QuestionCountNode!]!
    numSubmissions: Int!
    numUntouchedQuestions: [QuestionCountNode!]!
}

type SetBlacklistWords {
    error: String
    ok: Boolean
}

type SetCardUserInfo {
    ok: Boolean!
}

type SetItemStartTime {
    cardId: String
    errors: JSONString
    newProgress: JSONString
    ok: Boolean
}

type SetModelSolution {
    question: UGCQuestionV2Node!
}

type SetNotificationSetting {
    error: String
    notificationType: NotificationTypeNode
    ok: Boolean
}

type SetQuestionAsPrivate {
    question: UGCQuestionV2Node!
}

type SetUserConfig {
    error: String
    ok: Boolean!
}

type SkillSetNode {
    langLevels: [LanguageLevelNode!]!
    topicAreaScores: [TopicAreaScoreNode!]!
    topics: [TopicTagNode!]!
}

type SkillTagNode {
    name: String!
}

type SocialAccountNode {
    profileUrl: String
    provider: String
}

type SocialLoginNode {
    id: String
    loginUrl: String
}

type SolutionArticleConnection {
    "Contains the nodes in this connection."
    edges: [SolutionArticleEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `SolutionArticle` and its cursor."
type SolutionArticleEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: SolutionArticleNode
}

type SolutionArticleNode {
    articleType: ArticleType!
    author: UserNode!
    byLeetcode: Boolean!
    canEdit: Boolean!
    chargeType: ArticleChargeEnum!
    content: String!
    createdAt: DateTime!
    flagResult: FlagResultNode
    hasVideo: Boolean!
    hitCount: Int!
    identifier: String!
    isEditorsPick: Boolean!
    isMostPopular: Boolean!
    isMyFavorite: Boolean!
    nextSolution: String
    prevSolution: String
    question: QuestionNode!
    reactedType: ArticleReactions
    reactionType: ReactionTypeEnum
    reactions: [ArticleReactionCountNode!]
    reactionsV2: [ReactionCountNode!]
    resourceType: ResourceTypeEnum!
    score: Float
    slug: String!
    status: ArticleStatus!
    summary: String!
    tags: [CommonTagNode!]!
    thumbnail: String!
    title: String!
    topic: TopicNode
    updatedAt: DateTime
    upvoteCount: Int!
    upvoted: Boolean!
    uuid: ID!
    videosInfo: [VideoInfoNode!]
}

type SolutionNode {
    code: String!
    expectResult: JudgeResultStatus
    isModelSolution: Boolean!
    lang: String!
    result: UGCJudgeResultNode
    solutionId: ID!
}

type SponsorNode {
    description: String!
    logo: String
    name: String!
    watermark: String
    website: String!
}

type StoreGenerateRedeemCodes {
    codes: [String!]!
}

type SubjectNode {
    hidden: Boolean!
    id: ID!
    level: Int!
    order: Int!
    slug: ID!
    title: String!
}

type SubmissionDumpNode {
    id: ID
    isPending: String
    lang: String
    memory: String
    runtime: String
    statusDisplay: String
    time: String
    timestamp: String
    title: String
    url: String
}

type SubmissionListNode {
    hasNext: Boolean
    lastKey: String
    submissions: [SubmissionDumpNode]
}

type SubmissionNode {
    code: String!
    id: ID!
    "lang slug"
    lang: String!
    memory: String!
    outputDetail: SubmissionOutputNode!
    passedTestCaseCnt: Int!
    runtime: String!
    statusDisplay: String!
    timestamp: Int!
    totalTestCaseCnt: Int!
}

type SubmissionOutputNode {
    codeOutput: String!
    compileError: String!
    expectedOutput: String!
    input: String!
    inputFormatted: String!
    lastTestcase: String!
    runtimeError: String!
}

type SubmissionProgressNode {
    acSubmissions: Int!
    acTotal: Int!
    otherSubmissions: Int!
    questionTotal: Int!
    reSubmissions: Int!
    totalSubmissions: Int!
    waSubmissions: Int!
}

type SubmissionStatusNode {
    id: Int
    name: String
}

type SubmitQuestionTranslation {
    error: String
    ok: Boolean
    translation: TranslationNode
}

type SubscribeQuestion {
    ok: Boolean!
    questionId: String!
}

type SubscribeTopic {
    error: String
    ok: Boolean
    subscribe: Boolean
    topic: TopicNode
}

type TagNode {
    name: String!
    slug: String!
}

type TagToggleIsPublic {
    error: String
    ok: Boolean!
}

type TagTypeNode {
    name: String!
    slug: String!
}

type ToggleFavorite {
    cardId: String
    errors: JSONString
    isCurrentUserAuthenticated: Boolean
    isFavorite: Boolean
    newFavoriteCards: [CardNode!]
    ok: Boolean
}

type TogglePinTopic {
    error: String
    ok: Boolean
    topic: TopicNode
}

type TopicAreaNode {
    name: String!
    slug: String!
}

type TopicAreaScoreNode {
    "normalized score. range: [0, 100]"
    score: Int
    topicArea: TopicAreaNode!
}

type TopicConnection {
    "Contains the nodes in this connection."
    edges: [TopicEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `Topic` and its cursor."
type TopicEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: TopicRelayNode
}

type TopicNode {
    authors: [UserNode]
    category: DiscussCategoryNode
    commentCount: Int!
    contestSet: [ContestNode!]!
    flagResult: AdminLogFlagResultNode
    flags: [FlagNode!]!
    id: Int!
    index: Int
    kind: TopicType
    lastActivity: Int
    lastComment: CommentNode
    nodebbTid: Int!
    pinned: Boolean!
    pinnedAt: DateTime
    pinnedGlobally: Boolean!
    post: PostNode!
    subscribed: Boolean
    sunk: Boolean!
    tags: [String!]!
    title: String!
    topLevelCommentCount: Int!
    viewCount: Int!
}

type TopicRelayNode implements Node {
    commentCount: Int!
    commentSet(after: String, before: String, first: Int, last: Int): CommentRelayNodeConnection!
    contestSet: [ContestNode!]!
    flagResult: AdminLogFlagResultNode
    flags: [FlagNode!]!
    id: ID!
    kind: TopicKind!
    lastComment: CommentRelayNode
    nodebbTid: Int!
    pinned: Boolean!
    pinnedAt: DateTime
    pinnedGlobally: Boolean!
    post: PostNode!
    sunk: Boolean!
    tags: [CommonTagNode!]!
    title: String!
    topLevelCommentCount: Int!
    viewCount: Int!
}

type TopicTagConnection {
    "Contains the nodes in this connection."
    edges: [TopicTagEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `TopicTag` and its cursor."
type TopicTagEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: TopicTagNode
}

type TopicTagNode implements Node {
    company: InterviewCompanyNode
    createdAt: DateTime!
    frequencies: String
    "The ID of the object."
    id: ID!
    imgUrl: String
    isEnabled: Boolean!
    keywords: JSONString!
    name: String!
    questionIds: [Int]
    questionapplicationSet: [ApplicationNode!]!
    questions: [QuestionNode]
    quizzes: [QuizNode!]!
    slug: String!
    tagType: TagTypeNode!
    topicAreas: [TopicAreaNode!]!
    topics: [CommunityTopicNode!]!
    translatedName: String
}

type TranslationNode {
    content: String!
    createdAt: DateTime!
    id: ID!
    lang: String!
    lastModified: DateTime!
    provider: PrivateContestUserNode!
    question: QuestionNode!
    questionId: String!
    status: String
    title: String!
}

type UGCGenerateOutput {
    submitId: String!
}

type UGCGenerateOutputResult {
    codeAnswer: String
    codeOutput: [String!]!
    compileError: String
    fullCompileError: String
    runSuccess: Boolean!
    state: String!
    statusCode: JudgeResultStatus
}

type UGCGenerateOutputResultNode {
    output: UGCGenerateOutputResult
    outputFile: String!
}

type UGCInterpretSolution {
    expectInterpretSubmitId: String!
    interpretSubmitId: String!
    testcase: String!
}

type UGCJudgeResultNode {
    codeOutput: String!
    compareResult: String!
    compileError: String
    expectedOutput: String
    fullCompileError: String
    input: String
    inputFormatted: String
    runSuccess: Boolean!
    state: String!
    statusCode: JudgeResultStatus
    statusMemory: String!
    statusRuntime: String!
}

type UGCQuestionAdminLogConnection {
    "Contains the nodes in this connection."
    edges: [UGCQuestionAdminLogEdge]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    totalNum: Int
}

"A Relay edge containing a `UGCQuestionAdminLog` and its cursor."
type UGCQuestionAdminLogEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: UGCQuestionAdminLogNode
}

type UGCQuestionAdminLogNode {
    dateCreated: DateTime!
    eventType: EventType!
    ugcQuestion: UGCQuestionV2Node!
    user: PublicProfileNode!
}

type UGCQuestionCategoryNode {
    title: String!
    titleSlug: String!
}

type UGCQuestionSolutionNode {
    code: String!
    isModelSolution: Boolean!
    question: UGCQuestionV2Node!
    result: UGCJudgeResultNode
}

type UGCQuestionV2Node {
    authors: [PublicProfileNode!]!
    canGrantRoles: [String!]!
    createDate: DateTime!
    individuals: [PublicProfileNode!]!
    lastModified: DateTime!
    modifiedBy: PublicProfileNode!
    organizations: [ContributionOrganizationNode!]!
    permissions: [String!]!
    problemsetQuestion: QuestionNode
    questionData: QuestionDataNode!
    status: UGCQuestionStatus!
    ugcQuestionId: String!
}

type UGCQuestionsNode {
    nodes: [UGCQuestionV2Node!]!
    totalNum: Int
}

type UGCTestSolution {
    solutionId: String!
    submitId: String!
}

type UnfollowUser {
    error: String
    ok: Boolean!
}

type UnpublishContestAnnouncement {
    ok: Boolean
}

type UnsubscribeQuestion {
    ok: Boolean!
    questionId: String!
}

type UpdateApplicationIsRead {
    error: String
    ok: Boolean
}

type UpdateApplicationStatus {
    error: String
    ok: Boolean
}

type UpdateAppliedQuestionTranslation {
    appliedTranslation: AppliedTranslationNode
    error: String
    ok: Boolean
}

type UpdateBetaParticipation {
    error: String
    ok: Boolean
    userStatus: MeNode
}

type UpdateComment {
    comment: CommentNode
    error: String
    ok: Boolean
}

type UpdateContestGroupRegistrationInfo {
    registrationInfo: ContestGroupRegistrationInfoNode!
}

type UpdateContribution {
    contribution(id: ID): ContributionNode
    error: String
    ok: Boolean
}

type UpdateEducation {
    error: String
    ok: Boolean
    record: EducationRecordNode
}

type UpdateEmailPrimary {
    ok: Boolean
}

type UpdateInvalidUsername {
    error: String
    ok: Boolean
}

type UpdateJobStatus {
    error: String
    ok: Boolean
}

type UpdateNote {
    error: String
    ok: Boolean
    question: QuestionNode
}

type UpdateOccupation {
    error: String
    ok: Boolean
    record: OccupationRecordNode
}

type UpdateOrCreateOrganization {
    organization: ContributionOrganizationNode!
}

type UpdateOrCreatePromotion {
    promotion: OrganizationPromotionNode!
}

type UpdatePlayground {
    error: String
    ok: Boolean
}

type UpdatePlaygroundFolder {
    error: String
    ok: Boolean
}

type UpdateProblematicPost {
    error: String
    ok: Boolean
}

type UpdateProfile {
    error: String
    ok: Boolean
}

type UpdateProfileErrors {
    aboutMe: [String!]
    birthday: [String!]
    educationList: [String!]
    gender: [String!]
    industry: [String!]
    location: [String!]
    occupationList: [String!]
    realName: [String!]
    skillTags: [String!]
    websites: [String!]
}

type UpdateProfileIndustry {
    error: String
    ok: Boolean!
}

type UpdateQuestionTranslation {
    error: String
    ok: Boolean
    translation: TranslationNode
}

type UpdateTopic {
    error: String
    ok: Boolean
    topic: TopicNode
}

type UpdateTopicWithCategory {
    error: String
    topic: TopicNode
}

type UpdateTranslationConfig {
    ok: Boolean!
}

type UpdateUnifiedNotificationSettings {
    result: NotificationUnifiedSettingsNode!
}

type UpdateUserAvatarStatus {
    error: String
    ok: Boolean
}

type UpdateUserProfile {
    errors: UpdateProfileErrors
    profile: PublicProfileNode
}

type UpdateUserSchool {
    currentSchool: UserSchoolNode!
}

type UpdateUserSubjectSetting {
    error: String!
    ok: Boolean!
}

type UpdateUsername {
    error: String
    ok: Boolean
    userSlug: String
    username: String
    warning: String
}

type UploadTagImage {
    error: String
    ok: Boolean!
}

type UpvoteArticle {
    article: ArticleUnionNode
    error: String
    ok: Boolean!
}

type UserBannedInfoNode {
    bannedInfo: BannedUserNode
    isBanned: Boolean!
}

type UserBriefInfoNode {
    isOwner: Boolean!
    realName: String!
    userAvatar: String!
    userSlug: String!
    username: String!
}

type UserInvitationSettingNode {
    enableInvited: Boolean!
}

type UserListNode {
    totalNum: Int!
    users: [UserPermissionNode!]!
}

type UserMerchandiseEventNode {
    event: MerchandiseEventNode!
    prizeMeta: GenericScalar
    uniqueId: ID!
    user: UserNode!
}

type UserNode {
    email: String
    emails: [EmailNode]
    firstName: String!
    id: ID
    isDiscussAdmin: Boolean
    isDiscussStaff: Boolean
    isCurrentUserPremium: Boolean
    lastName: String!
    phone: String
    profile: UserProfileNode!
    socialAccounts: [String]
    username: String!
}

type UserNotificationNode {
    lastModified: Int
    numUnread: Int
}

type UserPermissionNode {
    accountName: String!
    createdAt: DateTime
    isEnabled: Boolean!
    modifiedAt: DateTime
    permissions: [NOJPermissionNode!]!
    remark: String!
    roles: [NOJRoleNode!]!
    user: UserNode!
}

type UserPlaygroundStateNode {
    createdNum: Int!
    upperLimitToCreate: Int!
}

type UserProfileNode {
    aboutMe: String!
    acStats: AcStatsNode
    age: Int
    asciiCode: String!
    birthday: String
    company: String!
    contestCount: Int
    countryCode: String
    countryName: String
    education: String
    gender: String
    globalRanking: Int
    identifier: String!
    industry: Industry
    lastModified: DateTime!
    location: String
    occupation: UserProfileOccupation
    privacyContact: Boolean
    ranking: UserRankingNode
    realName: String!
    reputation: Int!
    resourceType: ResourceTypeEnum!
    rewardStats: [String]
    school: String!
    skillSet: SkillSetNode!
    skillTags: [String]
    socialAccounts: [SocialAccountNode!]!
    userAvatar: String!
    userSlug: String!
    websites: [String]
    yearsOfExperience: Int
}

type UserRankingNode {
    currentGlobalRanking: Int!
    currentLocalRanking: Int!
    currentRating: String!
    ranking: String!
    rating: String!
    ratingProgress: [Int!]!
    totalGlobalUsers: Int!
    totalLocalUsers: Int!
}

type UserRatingNode {
    id: ID!
    score: Int!
}

type UserReportNode {
    createdAt: DateTime!
    handled: Boolean!
    id: ID!
    lastModified: DateTime!
    message: String!
    reportee: PrivateContestUserNode!
    reporter: PrivateContestUserNode!
}

type UserSchoolNode {
    graduationYear: Int!
    schoolName: String!
}

type UserSkillTagNode {
    id: ID!
    name: String!
    user: PrivateContestUserNode!
}

type UserUploadSchoolLogo {
    error: String
    ok: Boolean!
}

type ValidatePhoneCode {
    error: String
    ok: Boolean
}

type ValidateTestCase {
    error: String!
    ok: Boolean!
}

type VideoInfoNode {
    coverUrl: String!
    duration: Float!
    videoId: ID!
}

type VideoNode {
    "Collapsible HTML under video"
    content: String
    "Embedded HTML video"
    html: String!
    id: ID!
    paidOnly: Boolean!
}

type VideoRefreshedUploadCredentialNode {
    uploadAddress: String!
    uploadAuth: String!
}

type VideosGetUploadCredential {
    credential: VideosUploadCredentialNode!
}

type VideosRefreshUploadCredential {
    credential: VideoRefreshedUploadCredentialNode!
}

type VideosSaveUrl {
    video: VideosVideoNode!
}

type VideosUploadCredentialNode {
    uploadAddress: String!
    uploadAuth: String!
    videoId: String!
}

type VideosVideoNode {
    articleChargeType: ArticleChargeEnum!
    playAuth: String
    status: VideoStatusEnum!
    url: String!
    uuid: UUID!
    videoId: String!
    videoInfo: VideoInfoNode!
}

type VirtualContestScoreNode {
    contest: ContestNode
    finishTime: Int
    ranking: Int!
    score: Int!
    startTime: Int
    totalAcQuestions: Int!
    totalQuestions: Int
    totalScore: Int
    totalUsers: Int
}

type VoteForItem {
    ok: Boolean!
}

type VoteItemNode {
    imgUrl: String!
    name: String!
    slug: String!
    voteCount: Int!
    voted: Boolean!
}

type VoteNode {
    date: DateTime!
    id: ID!
    post: PostNode!
    postId: Int
    type: Int
    user: PrivateContestUserNode!
}

type VotePost {
    error: String
    ok: Boolean
    post: PostNode
    value: Int
}

type VoteSubjectNode {
    description: String!
    slug: String!
    title: String!
    voteItems: [VoteItemNode!]!
}

type WebPageNode {
    html: String!
    id: ID!
    paidOnly: Boolean!
}

type WechatShareDataNode {
    "description"
    desc: String!
    imgUrl: String!
    link: String!
    title: String!
}

type WikiContribNode {
    content: String!
    createdAt: DateTime!
    entry: WikiEntryNode
    modifiedAt: DateTime!
    status: ContribStatus!
    user: UserNode!
}

type WikiContributeContent {
    entry: WikiEntryNode
}

type WikiEntryNode {
    content: String
    contrib: WikiContribNode
    createdAt: DateTime!
    isPublic: Boolean!
    modifiedAt: DateTime!
    tag: CommonTagNode!
}

type WikiToggleEntryPublicStatus {
    entry: WikiEntryNode
}

enum ActivitySubType {
    ANY_SUB_ACTIVITY
    FEED_ABOUT_ME
    FEED_MY_COMMENT
    FEED_MY_FOLLOW
    FEED_MY_SUBMISSION
    NOTIFICATION_ABOUT_ME
    NOTIFICATION_FOLLOW_INFO
    NOTIFICATION_FROM_SITE
}

enum AdPictureType {
    HOME_SIDE
    JOBS_HOME
    OTHER
    QUESTION_LIST_SIDE
    WEEKLY_EMAIL_FOOTER
}

enum AddableTagTypeEnum {
    ADDITIONAL_TOPIC
    QUIZ
}

enum ApplicationStatus {
    A_0
    A_1
    A_2
}

enum ArticleChargeEnum {
    FREE
    PREMIUM
    VIDEO_PREMIUM
}

enum ArticleFeedbackStatus {
    A_0
    A_1
    A_2
}

enum ArticleMetaDataEnum {
    ALWAYS_EXPAND
    ALWAYS_SHOW
}

enum ArticleOrderBy {
    DEFAULT
    HOT
    LATEST
}

enum ArticleReactions {
    AWESOME
    CONFUSED
    GOOD
}

enum ArticleStatus {
    DELETED
    DRAFT
    PENDING
    PREPUBLISH
    PUBLISHED
    REMOVED
    UPDATE_REQUESTED
}

enum ArticleType {
    ANSWER
    QUESTION
    SOLUTION
    UNDEFINED
}

enum AvatarStatusEnum {
    ALL
    UNVIEWED
    VIEWED
}

enum CardExtraFieldsValueType {
    #string
    A_0
    #boolean
    A_1
    #int
    A_2
    #float
    A_3
    #object(dict)
    A_4
    #array(list)
    A_5
}

enum CardHavingExtraInfo {
    A_0
    A_1
    A_2
}

enum CnCommentSortEnum {
    NEW_TO_OLD
    OLD_TO_NEW
}

enum CommentOrderBy {
    HOT
    NEW_TO_OLD
    OLD_TO_NEW
}

enum CommentReplyOrderBy {
    NEW_TO_OLD
    OLD_TO_NEW
}

enum CommentTargetType {
    ALL
    ARTICLE
    QUESTION
    TOPIC
}

enum CompanyAccountType {
    ADMIN
    RECRUITER
}

enum CompanyFinancingStage {
    #Unfinanced
    A_0
    #Angel round
    A_1
    #Series A round
    A_2
    #Series B round
    A_3
    #Series C round
    A_4
    #Series D round or later
    A_5
    #Publicly listed
    A_6
    #No financing required
    A_7
}

enum CompanyIndustry {
    A_0
    A_1
    A_10
    A_11
    A_12
    A_13
    A_14
    A_15
    A_16
    A_17
    A_18
    A_19
    A_2
    A_20
    A_3
    A_4
    A_5
    A_6
    A_7
    A_8
    A_9
}

enum CompanyScale {
    #1-15 employees
    A_0
    #15-50 employees
    A_1
    #50-150 employees
    A_2
    #150-500 employees
    A_3
    #500-2000 employees
    A_4
    #2000 or more employees
    A_5
}

enum CompanyStage {
    ONLINE_ASSESSMENT
    ONSITE_INTERVIEW
    PHONE_INTERVIEW
}

enum ContentReviewType {
    ARTICLE
    COMMENT
    DISCUSS
    REPLY
    SOLUTION
}

enum ContribStatus {
    ACCEPTED
    DELETED
    UNHANDLED
}

enum Difficulty {
    EASY
    HARD
    MEDIUM
}

enum DifficultyEnum {
    EASY
    HARD
    MEDIUM
}

enum EntityType {
    ARTICLE
    COMMUNITY
    COMMUNITY_QA
    COMMUNITY_TOPIC
}

enum EventType {
    ADD
    ADD_TO_APPROVED
    BRING_BACK
    BRING_BACK_FROM_APPROVED
    BRING_BACK_FROM_DELETE
    BRING_BACK_FROM_IGNORE
    BY_LEETCODE
    DELETE
    DELETE_MANAGEMENT_ADMIN
    DISABLED_PERMISSION
    EDITOR_PICKED
    EDIT_REQUESTED
    FEATURED_ACCEPTED
    FEATURED_REJECT
    FLAGGED_APPROVED
    FLAGGED_IGNORE
    FLAGGED_REMOVED
    HANDLE_FEEDBACK
    MODIFY
    PINNED
    PINNED_GLOBALLY
    REVIEW_ACCEPT
    REVIEW_DELETE
    REVIEW_EDIT_REQUEST
    REVIEW_REJECT
    SUNK
}

enum ExamModeEnum {
    PRIVATE
    PUBLIC
}

enum ExamParticipationTypeEnum {
    OPEN
    REGULAR
    TESTER
}

enum ExamQuestionStatusEnum {
    ATTEMPTED
    NOT_STARTED
    SOLVED
}

enum ExamQuizSubmissionStatusEnum {
    ACCEPTED
    UNJUDGED
    UNNECESSARY
    UNSUBMITTED
    WRONG_ANSWER
}

enum ExamQuizzesReplyStatusEnum {
    JUDGED
    UNJUDGED
}

enum ExamReportOrderEnum {
    AC_QUESTION_CNT
    AC_QUIZ_CNT
    ATTENDED
    EMAIL
    EMPLOYEE_ID
    FULL_NAME
    RANKING
    SCORE
    TIME_USED
}

enum ExamResultType {
    BY_PARTICIPANT
    BY_SUBMISSION
}

enum ExamSampleFileEnum {
    IMPORT_EXAM_PARTICIPATIONS
}

enum ExamSendEmailVerificationError {
    EMAIL_INVALID
    OTHER
}

enum ExamType {
    FIXED_START_TIME
    FREE_START_TIME
}

enum ExamTypeEnum {
    FIXED_START_TIME
    FREE_START_TIME
}

enum FeatureGuideType {
    OTHER
    PROFILE_ASCII_CODE
    QUESTION_DETAIL_TOUR
}

enum FeaturedRequestType {
    ARTICLE
    REPLY
    SOLUTION
}

enum FlagResultStatus {
    A_0
    A_1
    A_2
    A_3
    A_4
}

enum FlagStatus {
    APPROVED
    EDIT_REQUESTED
    FLAGGED
    IGNORED
    REMOVED
}

enum FlaggableObjectSortFieldEnum {
    FLAG_COUNT
    LAST_FLAG_TIME
}

enum FlaggedObjectListOrderByEnum {
    FIRST_FLAGGED_TIME
    FLAGGED_COUNT
}

enum Gender {
    FEMALE
    MALE
    OTHER
}

enum Group {
    authentication_reviewer
    columns_admin
    columns_content_contributor
    community_beta_user
    contest_discuss_admin
    discuss_admin
    enterprise_open_user
    everyone
    explore_content_creator
    internal_contest_organizer
    internal_contest_participant
    internal_translator
    library_admin
    ugc_library_admin
    ugc_library_organization_owner
    wiki_admin
}

enum HandledReviewStatusType {
    ACCEPTED
    EDIT_REQUEST
    PENDING
}

enum HandledStatusType {
    ACCEPTED
    PENDING
    REJECTED
}

enum Industry {
    ADVERTISEMENT
    AI
    BLOCKCHAIN
    CLASSIFIED_INFORMATION
    CULTURAL_ENTERTAINMENT
    DATA_SERVICE
    DOMESTIC_SERVICES
    EDUCATION
    ENTERPRISE_SERVICES
    E_COMMERCE
    FINANCE
    GAME
    HARDWARE
    MEDICAL_HEALTH
    MOBILE_INTERNET
    O2O
    OTHER
    RECRUITMENT
    SECURITY
    SOCIAL_NETWORK
    TOURISM
}

enum JobPostingEducation {
    A_0
    A_1
    A_2
    A_3
    A_4
}

enum JobPostingStatus {
    A_0
    A_1
}

enum JobPostingStatusEnum {
    EXPIRED
    PUBLISHED
}

enum JobPostingWorkExperience {
    A_0
    A_1
    A_2
    A_3
    A_4
    A_5
}

enum JobPromotionChannel {
    A_0
}

enum JudgeResultStatus {
    AC
    CE
    IE
    MLE
    OLE
    RE
    TLE
    TO
    WA
}

enum LimitType {
    ONLY_NEW
    TIMES_LIMIT
    UNLIMIT
}

enum MatchType {
    MATCH_APPROXIMATE_DOUBLE
    MATCH_EXACT
    MATCH_VECTORS_NO_ORDER
}

enum MerchandiseType {
    #Premium membership
    A_1
}

enum NotificationChannel {
    EMAIL
    PUSH_NOTIFICATION
    SITE_NOTIFICATION
}

enum NotificationIdentifier {
    ACTIVITY_OF_FOLLOWED_QUESTIONS
    ACTIVITY_OF_FOLLOWED_USERS
    ARTICLE_COMMENTED_ON
    ARTICLE_UPVOTED
    COMMENT_REPLIED
    COMMENT_UPVOTED
    CONTEST_ANNOUNCEMENT
    FOLLOWED_BY_OTHERS
    JOB_RECOMMENDATION
    MENTIONED
    WEEKLY_EMAIL
}

enum Permission {
    authentication_ignore_beta_user_flow
    authentication_review_flagged_user
    authentication_see_user_email
    authentication_see_user_id
    authentication_send_global_notification
    authentication_update_school_info
    columns_add_article
    columns_change_article
    columns_delete_article
    columns_pick_article
    columns_review_article
    columns_see_columns
    common_change_tag
    contest_private_access_dashboard
    contest_see_private
    contest_see_private_contest_group
    discuss_change_contest_post
    discuss_change_post
    discuss_delete_contest_post
    discuss_delete_post
    discuss_pin_contest_topic
    discuss_pin_topic
    discuss_review_contest_post
    discuss_review_post
    discuss_see_circle
    discuss_see_contest_hiden_post
    discuss_see_hiden_post
    library_change_question
    library_see_all_fields
    library_see_all_problems
    pipeline_run_award_score
    pipeline_run_clone_lib_questions
    pipeline_run_delete_questions
    pipeline_run_json_to_question
    pipeline_run_sync_problems
    problemset_see_app_code_editor
    problemset_see_contest_questions
    ugc_library_add_ugcquestionv2
    ugc_library_change_ugcquestionv2
    ugc_library_delete_ugcquestionv2
    ugc_library_review_organization
    ugc_library_review_question
    ugc_library_view_ugcquestionv2
    wiki_add_wikicontrib
    wiki_add_wikientry
    wiki_change_wikicontrib
    wiki_change_wikientry
    wiki_delete_wikicontrib
    wiki_delete_wikientry
    wiki_review_wikicontrib
    wiki_view_wikicontrib
    wiki_view_wikientry
}

enum Platform {
    APNS
    FCM
}

enum PlaygroundCodeLang {
    #cpp
    A_0
    #java
    A_1
    #golang
    A_10
    #python3
    A_11
    #scala
    A_12
    #kotlin
    A_13
    #mssql
    A_14
    #oraclesql
    A_15
    #html
    A_16
    #pythonml
    A_17
    #rust
    A_18
    #php
    A_19
    #python
    A_2
    #mysql
    A_3
    #c
    A_4
    #csharp
    A_5
    #javascript
    A_6
    #ruby
    A_7
    #bash
    A_8
    #swift
    A_9
}

enum PlaygroundSelectedLang {
    #cpp
    A_0
    #java
    A_1
    #golang
    A_10
    #python3
    A_11
    #scala
    A_12
    #kotlin
    A_13
    #mssql
    A_14
    #oraclesql
    A_15
    #html
    A_16
    #pythonml
    A_17
    #rust
    A_18
    #php
    A_19
    #python
    A_2
    #mysql
    A_3
    #c
    A_4
    #csharp
    A_5
    #javascript
    A_6
    #ruby
    A_7
    #bash
    A_8
    #swift
    A_9
}

enum PlaygroundSnippetsLang {
    #cpp
    A_0
    #java
    A_1
    #golang
    A_10
    #python3
    A_11
    #scala
    A_12
    #kotlin
    A_13
    #mssql
    A_14
    #oraclesql
    A_15
    #html
    A_16
    #pythonml
    A_17
    #rust
    A_18
    #php
    A_19
    #python
    A_2
    #mysql
    A_3
    #c
    A_4
    #csharp
    A_5
    #javascript
    A_6
    #ruby
    A_7
    #bash
    A_8
    #swift
    A_9
}

enum PlaygroundTemplateCodeLang {
    #cpp
    A_0
    #java
    A_1
    #golang
    A_10
    #python3
    A_11
    #scala
    A_12
    #kotlin
    A_13
    #mssql
    A_14
    #oraclesql
    A_15
    #html
    A_16
    #pythonml
    A_17
    #rust
    A_18
    #php
    A_19
    #python
    A_2
    #mysql
    A_3
    #c
    A_4
    #csharp
    A_5
    #javascript
    A_6
    #ruby
    A_7
    #bash
    A_8
    #swift
    A_9
}

enum PostStatusEnum {
    ALL
    OPEN
    PENDING
    REPORTED
}

enum ProgressStatus {
    ACCEPTED
    ATTEMPTED
    UNATTEMPTED
}

enum QAAnswerListOrderEnum {
    HOTTEST
    LATEST
}

enum QAOrderEnum {
    HOTTEST
    LATEST
}

enum QuestionOwnershipEnum {
    COMPANY
    LEETCODE
}

enum QuestionTypeEnum {
    #Explore
    EXPLORE
    #Main
    MAIN
    #UGC
    UGC
}

enum QuizDifficultyEnum {
    EASY
    HARD
    MEDIUM
    OVER_MEDIUM
    VERY_EASY
    VERY_HARD
}

enum QuizKindEnum {
    MAIN
    SUB
}

enum QuizSampleFileTypeEnum {
    IMPORT_QUIZZES
}

enum QuizTypeEnum {
    BLANK_FILLING
    CHECKBOXES
    COMPOUND
    ESSAY
    MULTIPLE_CHOICE
    SCALE
}

enum ReactionTypeEnum {
    AWESOME
    CONFUSED
    UPVOTE
}

enum RegistrationTypeEnum {
    EMAIL
    PHONE
}

enum ReportTypeEnum {
    ABUSE
    ADVERTISING
    ALL
    FAKE
    ILLEGAL
    NON_ENGLISH
    OTHER
    POLITICS
    SEXUAL
    TERRORISM
    VIOLENT
}

enum RequestObjectSortFieldEnum {
    REQUEST_TIME
}

enum RequestObjectStatusEnum {
    ACCEPTED
    PENDING
    REJECTED
}

enum ResolverNamespaceEnum {
    COMMON
    EE
    NOJ
}

enum ResourceTypeEnum {
    ARTICLE
    COMMENT
    TOPIC
    USER
}

enum ReviewContentActionType {
    ACCEPT
    EDIT_REQUEST
    REMOVE
}

enum ScoreCategory {
    #ADD_QUESTION
    A_0
    #ADD_TESTCASE
    A_1
    #QUESTION_TRANSLATION_ACCEPTED
    A_10
    #CUSTOM
    A_100
    #ACCOUNT_TRANSFER
    A_11
    #BASIC_INFO_PROVIDED
    A_12
    #AVATAR_PROVIDED
    A_13
    #EXPERIENCE_PROVIDED
    A_14
    #PHONE_BINDING
    A_15
    #POST_TOPIC
    A_16
    #JOIN_CONTEST_FIRST_TIME
    A_17
    #EMAIL_CONFIRMED
    A_18
    #JOIN_INTERNAL_CONTEST
    A_19
    #TOP_IN_CONTEST
    A_2
    #FESTIVAL
    A_20
    #SOLUTION_PICKED_BY_EDITOR
    A_21
    #FIRST_QUESTION_SOLUTION
    A_22
    #COMMUNITY_ARTICLE_PICKED_BY_EDITOR
    A_23
    #QA_ANSWER_PICKED_BY_EDITOR
    A_24
    #WIKI_CONTRIBUTION
    A_25
    #JOIN_CONTEST
    A_3
    #SOCIAL_ACCOUNT_BINDING
    A_4
    #DAILY_LOGIN
    A_5
    #SEVEN_DAY_LOGIN
    A_6
    #THIRTY_DAY_LOGIN
    A_7
    #REDEEM
    A_8
    #CREATE_QUESTION_TRANSLATION
    A_9
}

enum SessionStatus {
    ACCEPTED
    EXITED
    STARTED
    TIMEOUT
}

enum SolutionArticleOrderBy {
    DEFAULT
    HOT
    MOST_UPVOTE
    NEWEST_TO_OLDEST
    OLDEST_TO_NEWEST
}

enum SortFieldEnum {
    LAST_SUBMITTED_AT
    NUM_SUBMITTED
    QUESTION_FRONTEND_ID
}

enum SortingOrderEnum {
    ASCENDING
    DESCENDING
}

enum SourceTypeEnum {
    ENTERPRISE_COMPANY
    LEETCODE
}

enum StatusEnum {
    ACCEPTED
    IGNORED
    PENDING
}

enum StatusFilterEnum {
    ACCEPTED
    FAILED
    UNTOUCHED
}

enum SubmissionLang {
    #cpp
    A_0
    #java
    A_1
    #golang
    A_10
    #python3
    A_11
    #scala
    A_12
    #kotlin
    A_13
    #mssql
    A_14
    #oraclesql
    A_15
    #html
    A_16
    #pythonml
    A_17
    #rust
    A_18
    #php
    A_19
    #python
    A_2
    #mysql
    A_3
    #c
    A_4
    #csharp
    A_5
    #javascript
    A_6
    #ruby
    A_7
    #bash
    A_8
    #swift
    A_9
}

enum SubmissionMemoryComplexity {
    #O(1)
    A_1
    #O(2ⁿ)
    A_10
    #O(n!)
    A_11
    #O(log n)
    A_2
    #O(n)
    A_3
    #O(n log n)
    A_4
    #O(n²)
    A_5
    #O(n³)
    A_6
    #O(n⁴)
    A_7
    #O(n⁵)
    A_8
    #O(n⁶)
    A_9
}

enum SubmissionStatus {
    #Accepted
    A_10
    #Wrong Answer
    A_11
    #Memory Limit Exceeded
    A_12
    #Output Limit Exceeded
    A_13
    #Time Limit Exceeded
    A_14
    #Runtime Error
    A_15
    #Internal Error
    A_16
    #Compile Error
    A_20
    #Timeout
    A_30
}

enum SubmissionTimeComplexity {
    #O(1)
    A_1
    #O(2ⁿ)
    A_10
    #O(n!)
    A_11
    #O(log n)
    A_2
    #O(n)
    A_3
    #O(n log n)
    A_4
    #O(n²)
    A_5
    #O(n³)
    A_6
    #O(n⁴)
    A_7
    #O(n⁵)
    A_8
    #O(n⁶)
    A_9
}

enum TagFreqRange {
    ALL
    ONE_YEAR
    SIX_MONTH
    TWO_YEAR
}

enum TagTypeEnum {
    ADDITIONAL_TOPIC
    COMPANY
    QUIZ
    SKILL
    TOPIC
}

enum TemplateFileEnum {
    AUTHORIZATION
}

enum TopicKind {
    #UNDEFINED
    A_0
    #QUESTION
    A_1
    #COMMUNITY
    A_2
    #ARTICLE
    A_3
}

enum TopicOrderBy {
    DEFAULT
    HOT
    LATEST
}

enum TopicSortingOption {
    most_posts
    most_relevant
    most_votes
    newest_to_oldest
    oldest_to_newest
    recent_activity
}

enum TopicTagTagType {
    #Company
    A_0
}

enum TopicType {
    ARTICLE
    COMMUNITY
    QUESTION
    UNDEFINED
}

enum UGCQuestionSortFieldEnum {
    CREATE_DATE
    DISPLAY_ID
    LAST_MODIFIED
}

enum UGCQuestionStatus {
    DELETED
    DRAFT
    REMOVED
    SYNC_FAILURE
    SYNC_PENDING
    SYNC_SUCCESS
    UPDATE_REQUESTED
}

enum UserBannedStatus {
    BANNED
    CANCELED
    UNBANNED
}

enum UserProfileOccupation {
    OTHER
    PROFESSIONAL
    STUDENT
}

enum VerbType {
    ACCEPT_DELETE_QAQUESTION
    ACCEPT_PICKED_REQUEST
    ANY_VERB
    ARTICLE_COMMENT_REFER
    ARTICLE_FEEDBACK
    ARTICLE_REFER
    BAN_USER
    CANCEL_ARTICLE
    COLLECT_ARTICLE
    COLLECT_PROBLEM
    COLLECT_TOPIC
    COMMENT_ARTICLE
    COMMENT_ARTICLE_AGG
    COMMENT_PROBLEM
    COMMENT_QAANSWER
    COMMENT_TOPIC
    COMMENT_TOPIC_AGG
    DELETE_ARTICLE
    DELETE_COMMENT
    FOLLOW
    JOB_INVITE
    LEETCODE_NOTIFY
    PROBLEM_ADD_ARTICLE
    PROBLEM_COMMENT_REFER
    QAANSWER_COMMENT_REFER
    QAANSWER_REFER
    QAQUESTION_ADD_ANSWER
    QAQUESTION_REFER
    QUESTION_FEEDBACK
    REACH_JOB_STANDARD
    REJECT_DELETE_QAQUESTION
    REJECT_PICKED_REQUEST
    REPLY_ARTICLE_COMMENT
    REPLY_PROBLEM_COMMENT
    REPLY_QAANSWER_COMMENT
    REPLY_TOPIC_COMMENT
    SITE_NOTIFY
    SUBMIT_CODE
    SUBSCRIBE_ARTICLE
    SUBSCRIBE_QAQUESTION
    SUBSCRIBE_TOPIC
    TOPIC_COMMENT_REFER
    TOPIC_REFER
    UPDATE_ARTICLE
    UPDATE_QAQUESTION
    UPDATE_REQUESTED
    UPDATE_TOPIC
    UPVOTE_ARTICLE
    UPVOTE_ARTICLE_COMMENT
    UPVOTE_PROBLEM
    UPVOTE_PROBLEM_COMMENT
    UPVOTE_QAANSWER
    UPVOTE_QAANSWER_COMMENT
    UPVOTE_TOPIC
    UPVOTE_TOPIC_COMMENT
    USER_ADD_ARTICLE
    USER_PUBLISH_QAANSWER
    USER_PUBLISH_QAQUESTION
    USER_PUBLISH_TOPIC
}

enum VideoFetchInfoType {
    PLAY_AUTH
    URL
}

enum VideoStatusEnum {
    APPROVED
    PENDING
    REJECTED
    TRANSCODE_FAILED
    TRANSCODING
}

input AddFavArticleInput {
    articleId: ID
    articleSlug: String
}

input AddTagInput {
    enable: Boolean!
    isPublic: Boolean
    keywords: [String!]!
    name: String!
    slug: String!
    tagType: TagTypeEnum!
}

input ApplyForAJobInput {
    description: String
    email: String
    jobId: ID!
    phone: String
    resume: String
    userRealName: String
}

input AuthCompletePhoneSignUpInput {
    nickname: String!
    password: String!
}

input AuthPasswordChangeInput {
    oldPassword: String!
    password1: String!
    password2: String!
}

input AuthResetPasswordInput {
    key: String!
    password1: String!
    password2: String!
    uidb36: String!
}

input AuthSetPasswordInput {
    password1: String!
    password2: String!
}

input AuthSignInWithPasswordInput {
    password: String!
    "email, phone or username"
    username: String!
}

input AuthSignInWithPhoneInput {
    code: String!
    phone: String!
}

input AuthSignUpWithEmailInput {
    email: String!
    nickname: String!
    password: String!
}

input AuthSignupInput {
    email: String
    nickname: String!
    password1: String!
    password2: String!
    phone: String
    phoneCode: String
    registrationType: RegistrationTypeEnum!
}

input AutoSaveArticleInput {
    content: String!
    slug: String
    subjectSlug: String!
    tags: [String!]!
    thumbnail: String!
    title: String!
    uuid: ID
}

input AutoSaveSolutionArticleInput {
    content: String!
    questionSlug: String!
    slug: String
    tags: [String!]!
    title: String!
}

input BatchReviewFlaggedObjectsInput {
    description: String
    flagResultIds: [ID!]!
    operation: FlagStatus!
    reasonId: ID
}

input BlockingBlockArticleInput {
    action: Boolean!
    articleId: String!
    articleType: ArticleType!
}

input CartItemInput {
    discountId: ID
    number: Int!
    productId: ID!
}

input ColumnsReactionInput {
    action: Boolean!
    "uuid"
    articleId: ID!
    reactionType: ReactionTypeEnum
}

input CreateAddressInput {
    chinaLocationCode: String!
    detailedAddress: String!
    isDefault: Boolean!
    orderId: String
    phoneNumber: String!
    postcode: String
    receiver: String!
}

input CreateCompanyUserInput {
    accountType: CompanyAccountType!
    chinaCity: Int
    comment: String
    username: String!
}

input CreateOrderInput {
    body: String
    cartItems: [CartItemInput]!
    descriptionMeta: String
    subject: String
}

input DeleteAddressInput {
    addressId: String!
    orderId: String
}

input EditCompanyInput {
    authorization: String
    businessLicense: String
    companySlug: String!
    description: String
    financingStage: String
    industry: String
    legalName: String
    logo: String
    name: String
    scale: String
    website: String
}

input EditCompanyUserInput {
    accountType: CompanyAccountType!
    chinaCity: Int
    comment: String
    id: ID!
    username: String!
}

input EditTagInput {
    enable: Boolean
    id: ID!
    isPublic: Boolean
    keywords: [String!]!
    name: String!
    slug: String!
}

input EducationInput {
    id: ID
    schoolName: String
}

input ExamCreateExamInput {
    allowedLanguages: [String!]
    comment: String
    description: String
    "seconds"
    duration: Int
    endAt: Int!
    frozenOpenMaxNumber: Int
    mode: ExamModeEnum
    name: String!
    participants: [ID!]
    questions: [ExamQuestionInput!]
    quizzes: [ExamQuizInput!]
    rules: String!
    startAt: Int!
    templates: [UUID!]
    testers: [ID!]
    type: ExamTypeEnum!
}

input ExamEditExamInput {
    allowedLanguages: [String!]
    comment: String
    description: String
    displayId: ID!
    "seconds"
    duration: Int
    endAt: Int!
    frozenOpenMaxNumber: Int
    mode: ExamModeEnum
    name: String!
    participants: [ID!]
    questions: [ExamQuestionInput!]
    quizzes: [ExamQuizInput!]
    rules: String!
    startAt: Int!
    templates: [UUID!]
    testers: [ID!]
    type: ExamTypeEnum!
}

input ExamLoginData {
    code: String!
    email: String!
    examId: ID!
}

input ExamPasswordLoginInput {
    examId: ID!
    login: String!
    password: String!
}

input ExamQuestionInput {
    questionId: ID!
    score: Int!
    submissionLimit: Int
}

input ExamQuizInput {
    childrenScore: JSONString
    quizUid: ID!
    score: Int!
}

input ExamQuizSubmissionInput {
    uid: ID!
    userAnswer: String!
}

input ExamRunCodeInput {
    dataInput: String
    examId: ID!
    lang: String!
    questionId: ID!
    testJudger: String
    testMode: Boolean
    typedCode: String!
}

input ExamSaveExamTemplateInput {
    description: String!
    name: String!
    questions: [ExamQuestionInput!]!
    quizzes: [ExamQuizInput!]!
    uuid: UUID
}

input ExamSubmitInput {
    examId: ID!
    lang: String!
    questionId: ID!
    testJudger: String
    testMode: Boolean
    typedCode: String!
}

input FlagInput {
    description: String
    reasonId: ID
    resourceId: String!
    resourceType: ResourceTypeEnum!
}

input GenerateQuestionTemplateInput {
    inputSchema: String!
    languages: [String!]!
    outputSchema: String!
}

input GrantedPremiumRecordsInput {
    after: String
    limit: Int
}

input InterviewedStatsInput {
    companyId: Int
    companyName: String
    interviewedStatsId: Int!
    isInterviewed: Boolean
    questionId: String!
    stageOption: Int
    timeOption: Int
}

input LCPNSaveDeviceTokenInput {
    deviceToken: String!
    platform: Platform!
}

input ManagementAddSubjectInput {
    hidden: Boolean!
    slug: String!
    title: String!
}

input ManagementCreateOrUpdateUserRoleInput {
    isEnabled: Boolean!
    remark: String!
    roleSlugs: [String!]!
    userName: String!
    userSlug: String!
}

input ManagementUpdateSubjectInput {
    hidden: Boolean!
    id: ID!
    slug: String!
    title: String!
}

input MergeTagsInput {
    enable: Boolean!
    isPublic: Boolean
    keywords: [String!]!
    name: String!
    slug: String!
    tagType: TagTypeEnum!
    tags: [ID!]!
}

input OAuthInput {
    clientId: String!
    clientSecret: String!
}

input OccupationInput {
    companyName: String!
    id: ID
    jobTitle: String!
}

input PayOrderInput {
    addressId: String
    channel: String!
    orderId: ID!
}

input PaySubscriptionOrderInput {
    orderUuid: String!
    payment: Int!
}

input PostAJobInput {
    description: String
    education: String
    jobId: ID
    location: String
    published: Boolean
    salaryMax: String
    salaryMin: String
    salaryNegotiable: Boolean
    title: String
    workExperience: String
    workLocations: [ID]!
}

input ProductByCategoryInput {
    after: String
    categorySlug: String!
    limit: Int
    promoChannel: String
}

input PublishArticleInput {
    content: String!
    mentionedUserSlugs: [String]!
    slug: String
    subjectSlug: String!
    summary: String!
    tags: [String]!
    thumbnail: String!
    title: String!
    uuid: ID
}

input PublishSolutionArticleInput {
    content: String!
    mentionedUserSlugs: [String]!
    questionSlug: String!
    slug: String
    summary: String!
    tags: [String]!
    thumbnail: String!
    title: String!
}

input QAEditAnswerInput {
    answerId: ID!
    content: String
    mentionedUserSlugs: [String!]!
    summary: String
    thumbnail: String
}

input QAEditQuestionInput {
    content: String
    mentionedUserSlugs: [String!]!
    subjectSlug: String
    summary: String
    tags: [String!]!
    thumbnail: String
    title: String!
    uuid: ID!
}

input QAPublishAnswerInput {
    content: String
    mentionedUserSlugs: [String!]!
    questionId: ID!
    summary: String
    thumbnail: String
}

input QAPublishQuestionInput {
    content: String
    mentionedUserSlugs: [String!]!
    subjectSlug: String!
    summary: String
    tags: [String!]!
    thumbnail: String
    title: String!
}

input QASetQuestionMetaDataInput {
    metaField: ArticleMetaDataEnum!
    questionId: ID!
    value: Boolean!
}

input QuizSaveInput {
    answer: JSONString!
    category: ID
    children: [QuizSaveInput!]
    content: String!
    difficulty: QuizDifficultyEnum!
    explanation: String!
    extraContent: JSONString!
    tags: [String!]
    type: QuizTypeEnum!
    uid: String
}

input RegisterForContestGroupInput {
    fullName: String!
    graduationYear: Int
    occupation: UserProfileOccupation!
    slug: String!
}

input RemoveFavArticleInput {
    articleId: ID
    articleSlug: String
}

input ReviewFlaggedObjectInput {
    description: String
    "Use this to locate the object. Will ignore resourceType and resourceId if this is provided."
    flagResultId: ID
    operation: FlagStatus!
    reasonId: ID
    "Use this together with resourceType as an alternative way to locate object."
    resourceId: String
    "Use this together with resourceId as an alternative way to locate object."
    resourceType: ResourceTypeEnum
}

input SendVerificationInput {
    csessionid: String!
    phoneNum: String!
    scene: String!
    sig: String!
    templateId: String!
    token: String!
}

input SetModelSolutionInput {
    isModelSolution: Boolean!
    solutionId: ID!
    ugcQuestionId: String!
}

input SetUserConfigInput {
    allowCreate: Boolean
    allowDisplay: Boolean
    verb: VerbType!
}

input SolutionInput {
    expectResult: JudgeResultStatus!
    id: ID!
}

input StoreGenerateRedeemCodesInput {
    expirationDate: Int!
    merchandiseId: ID!
    quantity: Int!
}

input UGCDraftInput {
    category: String!
    customLimits: JSONString
    customMatcher: String
    descriptionCn: String
    descriptionUs: String
    difficulty: Difficulty!
    displayId: String!
    individuals: [String!]!
    inputSchema: String
    isPrivate: Boolean
    manualCodeDefinitions: JSONString
    manualDrivers: JSONString
    matchType: MatchType!
    organizations: [String!]!
    outputSchema: String
    questionType: QuestionTypeEnum!
    solutions: [SolutionInput!]
    tags: [String!]!
    testcaseInFile: String
    testcaseOutFile: String
    titleCn: String!
    titleUs: String
    ugcQuestionId: String
}

input UGCGenerateOutputInput {
    code: String!
    lang: String!
    testcaseInFile: String!
    ugcQuestionId: String!
}

input UGCInterpretSolutionInput {
    code: String!
    dataInput: String!
    lang: String!
    ugcQuestionId: String!
}

input UGCQuestionInput {
    category: String!
    customLimits: JSONString
    customMatcher: String
    deletedSolutionFileNames: [String!]
    descriptionCn: String
    descriptionUs: String
    difficulty: Difficulty!
    displayId: String!
    individuals: [String!]!
    inputSchema: String
    isPrivate: Boolean
    manualCodeDefinitions: JSONString
    manualDrivers: JSONString
    matchType: MatchType!
    organizations: [String!]!
    outputSchema: String
    questionType: QuestionTypeEnum!
    solutions: [SolutionInput!]
    tags: [String!]!
    testcaseInFile: String
    testcaseOutFile: String
    titleCn: String!
    titleUs: String
    ugcQuestionId: String
}

input UGCTestSolutionInput {
    code: String!
    lang: String!
    "Only supports TestSolution interface: creates if not exist, updates if exists"
    solutionId: ID
    ugcQuestionId: String!
}

input UnifiedNotificationSettingsInput {
    enabledChannels: [NotificationChannel!]!
    identifier: NotificationIdentifier!
}

input UpdateAddressInput {
    addressId: String!
    chinaLocationCode: String!
    detailedAddress: String!
    isDefault: Boolean!
    orderId: String
    phoneNumber: String!
    postcode: String
    receiver: String!
}

input UpdateApplicationIsReadInput {
    applicationIds: [ID]!
    isRead: Boolean!
}

input UpdateApplicationStatusInput {
    applicationIds: [ID]!
    status: Int!
}

input UpdateContestGroupRegistrationInfoInput {
    fullName: String!
    graduationYear: Int
    occupation: UserProfileOccupation!
}

input UpdateJobStatusInput {
    jobIds: [ID]!
    status: Int!
}

input UpdateOrCreateOrganizationInput {
    avatarUrl: String
    description: String
    members: [String!]
    name: String!
    organizationId: ID
    remarks: String
}

input UpdateOrCreatePromotionInput {
    aboutLink: String
    avatarUrl: String
    description: String
    name: String!
    promotionId: ID
}

input UpdateProfileInput {
    aboutMe: String
    birthday: Date
    educationList: [EducationInput!]
    gender: Gender
    industry: Industry
    "<province>%<city>"
    location: String
    occupationList: [OccupationInput!]
    realName: String!
    skillTags: [String!]
    websites: [String!]
}

input ValidateTestCaseInput {
    inputSchema: String!
    outputSchema: String!
    testcaseInFile: String!
}

input VideosGetUploadCredentialInput {
    description: String
    fileName: String!
    title: String!
}

input WikiContributeContentInput {
    content: String!
    slug: String!
    tagType: TagTypeEnum!
}

input WikiToggleEntryPublicStatusInput {
    slug: String!
    tagType: TagTypeEnum!
    value: Boolean!
}


"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

"The `Decimal` scalar type represents a python Decimal."
scalar Decimal

"""
Leverages the internal Python implmeentation of UUID (uuid.UUID) to provide native UUID objects
in fields, resolvers and input.
"""
scalar UUID

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date
